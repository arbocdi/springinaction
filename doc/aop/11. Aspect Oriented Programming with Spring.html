<html><head>
    <base href="https://docs.spring.io/spring/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>11. Aspect Oriented Programming with Spring</title><style data-savepage-href="css/manual-multipage.css" type="text/css">/*savepage-import-url=manual.css*//*savepage-import-url=highlight.css*/.hl-keyword{color:#7f0055;font-weight:700}.hl-comment{color:#3f5f5f;font-style:italic}.hl-multiline-comment{color:#3f5fbf;font-style:italic}.hl-tag{color:#3f7f7f}.hl-attribute{color:#7f007f}.hl-value{color:#2a00ff}.hl-string{color:#2a00ff}html{padding:0;margin:0}body{color:#333;margin:15px 30px;font-family:Helvetica,Arial,Freesans,Clean,Sans-serif;line-height:1.6;-webkit-font-smoothing:antialiased}code{font-size:16px;font-family:Consolas,liberation mono,Courier,monospace;color:#6d180b}:not(pre)>code{background-color:#f2f2f2;border:1px solid #ccc;border-radius:4px;padding:1px 3px 0;text-shadow:none;white-space:nowrap}body>*:first-child{margin-top:0!important}div{margin:0}hr{border:1px solid #ccc;background:#ccc}h1,h2,h3,h4,h5,h6{color:#000;cursor:text;font-weight:700;margin:30px 0 10px;padding:0}h1,h2,h3{margin:40px 0 10px}h1{margin:70px 0 30px;padding-top:20px}div.part h1{border-top:1px dotted #ccc}h1,h1 code{font-size:32px}h2,h2 code{font-size:24px}h3,h3 code{font-size:20px}h4,h1 code,h5,h5 code,h6,h6 code{font-size:18px}div.book,div.chapter,div.appendix,div.part,div.preface{min-width:300px;max-width:1200px;margin:0 auto}p.releaseinfo{font-weight:700;margin-bottom:40px;margin-top:40px}div.authorgroup{line-height:1}p.copyright{line-height:1;margin-bottom:-5px}.legalnotice p{font-style:italic;font-size:14px;line-height:1}div.titlepage+p,div.titlepage+p{margin-top:0}pre{line-height:1;color:#000}a{color:#4183c4;text-decoration:none}p{margin:15px 0;text-align:left}ul,ol{padding-left:30px}li p{margin:0}div.table{margin:1em;padding:.5em;text-align:center}div.table table,div.informaltable table{display:table;width:100%}div.table td{padding-left:7px;padding-right:7px}.sidebar{line-height:1.4;padding:0 20px;background-color:#f8f8f8;border:1px solid #ccc;border-radius:3px 3px 3px 3px}.sidebar p.title{color:#6d180b}pre.programlisting,pre.screen{font-size:15px;padding:6px 10px;background-color:#f8f8f8;border:1px solid #ccc;border-radius:3px 3px 3px 3px;clear:both;overflow:auto;line-height:1.4;font-family:Consolas,liberation mono,Courier,monospace}table{border-collapse:collapse;border-spacing:0;border:1px solid #ddd!important;border-radius:4px!important;border-collapse:separate!important;line-height:1.6}table thead{background:#f5f5f5}table tr{border:none;border-bottom:none}table th{font-weight:700}table th,table td{border:none!important;padding:6px 13px}table tr:nth-child(2n){background-color:#f8f8f8}td p{margin:0 0 15px}div.table-contents td p{margin:0}div.important *,div.note *,div.tip *,div.warning *,div.navheader *,div.navfooter *,div.calloutlist *{border:none!important;background:0 0!important;margin:0}div.important p,div.note p,div.tip p,div.warning p{color:#6f6f6f;line-height:1.6}div.important code,div.note code,div.tip code,div.warning code{background-color:#f2f2f2!important;border:1px solid #ccc!important;border-radius:4px!important;padding:1px 3px 0!important;text-shadow:none!important;white-space:nowrap!important}.note th,.tip th,.warning th{display:none}.note tr:first-child td,.tip tr:first-child td,.warning tr:first-child td{border-right:1px solid #ccc!important;padding-top:10px}div.calloutlist p,div.calloutlist td{padding:0;margin:0}div.calloutlist>table>tbody>tr>td:first-child{padding-left:10px;width:30px!important}div.important,div.note,div.tip,div.warning{margin-left:0!important;margin-right:20px!important;margin-top:20px;margin-bottom:20px;padding-top:10px;padding-bottom:10px}div.toc{line-height:1.2}dl,dt{margin-top:1px;margin-bottom:0}div.toc>dl>dt{font-size:32px;font-weight:700;margin:30px 0 10px;display:block}div.toc>dl>dd>dl>dt{font-size:24px;font-weight:700;margin:20px 0 10px;display:block}div.toc>dl>dd>dl>dd>dl>dt{font-weight:700;font-size:20px;margin:10px 0 0}tbody.footnotes *{border:none!important}div.footnote p{margin:0;line-height:1}div.footnote p sup{margin-right:6px;vertical-align:middle}div.navheader{border-bottom:1px solid #ccc}div.navfooter{border-top:1px solid #ccc}.title{margin-left:-1em;padding-left:1em}.title>a{position:absolute;visibility:hidden;display:block;font-size:.85em;margin-top:.05em;margin-left:-1em;vertical-align:text-top;color:#000}.title>a:before{content:"\00A7"}.title:hover>a,.title>a:hover,.title:hover>a:hover{visibility:visible}.title:focus>a,.title>a:focus,.title:focus>a:focus{outline:0}body.firstpage{background:/*savepage-url=../images/background.png*/url() no-repeat center top}div.part h1{border-top:none}</style><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part III. Core Technologies"><link rel="prev" href="expressions.html" title="10. Spring Expression Language (SpEL)"><link rel="next" href="aop-api.html" title="12. Spring AOP APIs">
    <link rel="icon" href="data:image/vnd.microsoft.icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2JpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0idXVpZDpFRTE2MTIxNzQ3RUVERTExQkM5RkE3MDBBNkY0RDhDMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGMUMxRDM5QjBGNzAxMUUzODE3RkU5MEMxMzBDODE2MCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGMUMxRDM5QTBGNzAxMUUzODE3RkU5MEMxMzBDODE2MCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MkRDNDcwNzY0NDIwNjgxMTgyMkFFRkMyQjhBOEY0MEIiIHN0UmVmOmRvY3VtZW50SUQ9InV1aWQ6RUUxNjEyMTc0N0VFREUxMUJDOUZBNzAwQTZGNEQ4QzEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4SMlYtAAACRUlEQVR42oyTXUiTYRTH/+9a9jGTZvMjZZuVzhGrnEmNGmkZVFBESFdhgpYX4VUlUSnRVRfSRVIXQkJB1EWRUFBUOC1mRSNyi+xDg2hbCzc/2ObXyK3/8/a+gZXmgR/PeT7+D+c55zlSzfUy/GFrSS3ZRQpIggyQDnKFxMhe8oIMaYTi2mGPGLSkhbwlJ4iNpJNMsolcIF6yjlwkx4ROUiKQyG1Shf/bhC4tY8lYIhqkb9Ioi2fmKYYQH995CQs02nxOneICE2mejzg3w4ymPe1YY7DBlucQS5Xi3TVk0VzC/OWrsa1wPyqtB6HVLJTXNpoq4A24nVolozPMqC+C3ViO4pwSmPQWLFusn7GfSiVRmLVeuFZxwSp1Y4VuJeqd5ym0zxpNOP4NBl0uDOl5YmrQKKWSrXbL2TnFE4k4fMEeSJJGfUpSXBBQDxTnlM4qHhoL4fLTUyg1VvyKJCaqiC/igpfqocFY4C/hdPIHXB/voPn+IWy3VEG/NEtef+3vEoNL5OAqqRazjt42HNl6Tg5xMOpHb8CN7v67GB2P8HlNKDPvkMWxyRE8fHdDuLfUn3iP7CvK3sC3peH9d8/vCES2qzc3wpxpleeReAit3SfxdfjTB9E3WuVcnSXb/ur07rYCib+65UkDopPDOFBSL+dlfCqGN/5n8AbdeP75ARLTU0lqGtgLKa3STOGBsK+ObqdcZyThH+lHa1fjv/I5So5S06l2oBqqi4PjUd9NR1/II2pZrnxzkegI8ZHHpJ3iiKr7KcAAO/GrgtdfsmsAAAAASUVORK5CYII=">
    <script id="savepage-contentloaders" type="application/javascript">
      "use strict"
      savepage_ContentLoaders();
      function savepage_ContentLoaders()
      {
        var resourceMimeType = new Array();
        var resourceBase64Data = new Array();
        var resourceBlobUrl = new Array();
        window.addEventListener("DOMContentLoaded",
        function(event)
        {
          savepage_ShadowLoader(5);
          savepage_ResourceLoader(5);
          document.getElementById('savepage-contentloaders').remove();
        },false);
        function savepage_ShadowLoader(c){createShadowDOMs(0,document.documentElement);function createShadowDOMs(a,b){var i;if(b.localName=="iframe"||b.localName=="frame"){if(a<c){try{if(b.contentDocument.documentElement!=null){createShadowDOMs(a+1,b.contentDocument.documentElement)}}catch(e){}}}else{if(b.children.length>=1&&b.children[0].localName=="template"&&b.children[0].hasAttribute("data-savepage-shadowroot")){b.attachShadow({mode:"open"}).appendChild(b.children[0].content);b.removeChild(b.children[0]);for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)createShadowDOMs(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)createShadowDOMs(a,b.children[i])}}}
        function savepage_ResourceLoader(f){createBlobURLs();replaceReferences(0,document.documentElement);function createBlobURLs(){var i,j,binaryString,blobData;var a=new Array();for(i=0;i<resourceMimeType.length;i++){if(typeof resourceMimeType[i]!="undefined"){binaryString=atob(resourceBase64Data[i]);resourceBase64Data[i]="";a.length=0;for(j=0;j<binaryString.length;j++){a[j]=binaryString.charCodeAt(j)}blobData=new Blob([new Uint8Array(a)],{type:resourceMimeType[i]});resourceMimeType[i]="";resourceBlobUrl[i]=window.URL.createObjectURL(blobData)}}}function replaceReferences(a,b){var i,regex1,regex2,csstext,blobData;regex1=/url\(\s*((?:"[^"]+")|(?:'[^']+')|(?:[^\s)]+))\s*\)/gi;regex2=/data:[^;]*;resource=(\d+);base64,/i;if(b.hasAttribute("style")){csstext=b.style.cssText;b.style.cssText=csstext.replace(regex1,replaceCSSRef)}if(b.localName=="style"){csstext=b.textContent;b.textContent=csstext.replace(regex1,replaceCSSRef)}else if(b.localName=="link"&&(b.rel.toLowerCase()=="icon"||b.rel.toLowerCase()=="shortcut icon")){if(b.href!="")b.href=b.href.replace(regex2,replaceRef)}else if(b.localName=="body"){if(b.background!="")b.background=b.background.replace(regex2,replaceRef)}else if(b.localName=="img"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="input"&&b.type.toLowerCase()=="image"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="audio"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}}else if(b.localName=="video"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}if(b.poster!="")b.poster=b.poster.replace(regex2,replaceRef)}else if(b.localName=="source"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.parentElement.load()}}else if(b.localName=="track"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="object"){if(b.data!="")b.data=b.data.replace(regex2,replaceRef)}else if(b.localName=="embed"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}if(b.localName=="iframe"||b.localName=="frame"){if(a<f){if(b.hasAttribute("data-savepage-sameorigin")){blobData=new Blob([decodeURIComponent(b.src.substr(29))],{type:"text/html;charset=utf-8"});b.onload=function(){try{if(b.contentDocument.documentElement!=null){replaceReferences(a+1,b.contentDocument.documentElement)}}catch(e){}};b.src=window.URL.createObjectURL(blobData)}}}else{if(b.shadowRoot!=null){for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)replaceReferences(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)replaceReferences(a,b.children[i])}}function replaceCSSRef(a,b,c,d){var e=new Array();e=b.match(/data:[^;]*;resource=(\d+);base64,/i);if(e!=null)return"url("+resourceBlobUrl[+e[1]]+")";else return a}function replaceRef(a,b,c,d){return resourceBlobUrl[+b]}}
        resourceMimeType[4] = "image/png"; resourceBase64Data[4] = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAADAFBMVEX////BzDAbRRYmUiBDdzZbhUUYQhRCdDRMfDpqjlQhSxslUR8oVCF4mGMZQxUdRhceSBklVSM+bzFAcjPCzTAaRBUdRxgfSRkgSxsjTh0lUB4jUSArUh4oViIqVyMsXikzYSo1ZSuMpnjS2HAYQhMZQxQeSRofTh4jTRwlTx4hUSAmUR8nWCUsWSQtWyUuXCcwXic8YTI3aC45aS46azA8bTA8bjFJZj88cDM9cTRFeDdFejhGezhHfDlJfTpYeEpaekx0jS6Io3SZqzGVq4GntjCvvTC6xzG9yTHAyzDG0C3N1F3d4dbz8/P9/f0ZRxolTBkhTx8oTRogUiEkUSAjUiEkUiEqUSUsUiYmViQpVSIqVyQoWSYtWCMwVig0Vx8wWCk1VSw0VygzWiIxYCgvYSs0XykzYCgwYis1YS00YyozZSw0ZSw4aC08ZTI5ai45azA7bDBHZTlEailEaDhIZzpDbTRDczNBdDRBdjZDdjVDdjZCdzZIdjdCejlGezpJejhKejZKeTxWdixIfDlIfjpKfjpKfj1PfzxSfUJWgDVgfSxQgj5YgjZWgEZlfypYgkdThzxXhkNZhEljgERhflRjhjNbijtkgFdnflxihE5ciEppf15hiFBfik1nhVpjkDxkjE5kjFJrh11zhGlpjlNojlZwkjpskVZukVh1lUJ2mzt1lV17kG19mjZ5nDt2l193lWh4lWd4l2F+knJ9nzt5mWV6mmOInTaEmnaGmXmPpDGOpTWPpzaFonGHonSRp0SHo3OVqjOPoIKOooGZrDGVqFKLpniVrjiOpX6ZrjSQpoCYsDiRqX6jtDCjtjOdqZKcq5CgrJaqvDWuvDWtvzSpuV+vwDSitZKktZWzwjO2wzCmuJe3xTCuuaW/yjC8yEevvaLAyy/DzS/Ezi/Ezy/Fzy62v6y4vrK3wK7Fz0a8x7DL0lzAx7e/ybPBybfDy7zP1nDH0LzM08TN08bP1sbW3M7Y3NPf4OHk6ODo6ufr7Ozt7+r3+Pb6+/v8/PuD+5XzAAAB6klEQVR42mNggIJ3pzdN6Nt48vV/BhRwZ17Phn1KSge3T5p9A0nYZ1nrChcXJSen42evrbFb9A0m/rXdbuH+bbwgsFn52Cwb208Q8Z/1LW0rOcFg6QHlK1Nqbet8wBJzrW06WCFglTKj544yduvJIPGHlVZWDRxgsPwjI6OnR1phVc1NoERnNQsYNPbufcPI6OHO2KwgzNLEwPDZkh0Eutad9/ZmZGR8cJXxqJ5JheV7hiMWwsLC5XsYIeCp1H1Gt9gsIYudDIvNhISETkHFGV+VPmF0S9YzNpvP4GBiajoNJi5SdEaEkVEySrHAgcHeKN/4EEziOtcjRkZXTWYFI3uGGdm5ineh4reSTgA1OEpwp+RMZdiVqpi+G2yM12WBBY8ZGc9piHMbZKxl+CCvoN8NknDfKjYRSDnLiInzGMg/Z2DIk9eVcfViXM3EtP7Zbcd4JiZ+Ljn9TKDPL8ZEa8gU8/FNd+4P4ufjE2US19bVOQwKrBJBWTVVNrYANiBQZRLg4paLNASH7ndBHQl+JiZRFRVRfgEuKR45QcEvkAh5qR6sJikpISbApanNIysbFnoPGoP/XiT6q4dwS3Ez8/AwS2sZvoVFrZ/vjyVxgdLMQCCtlbDlLyIx+Pn+/nVpjnlEuPnMC3+gYgASQI+qWBZeAQAAAABJRU5ErkJggg==";
        resourceMimeType[8] = "image/png"; resourceBase64Data[8] = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAABgFBMVEX///+/zDEyYSkmUiAZQxUpVSNDdjYcRhcgShosWSQ9cDJFezlbhUUXQhQhTBwkTx4uXCZGeDcdSxwkUB81ZSxZeUpqjlSuvjK0wzEiUSAtXik0Yys3aC5CZSVIfTpMfDpKfjttkVd3l2GNpnq5xzLP1ogkVCMtUh0yVyo+YjRjfyxkilF3lTR5mWSEl3eGonOVrIKktpXF0Ei8xrHK017N1MX7+/slSxkhTh0mViQoWSYwYis9YSM1ZCs5aS48aTBJZj9KezlZdypSfEFQfzxVfzVTgjxZg0hjf1Zof11eiUxviS1pjDZ7ki+PoYKgqzaRqH+VrGaesjSitDOdqpGtuaK2vq3K0W/Cyrrd4dY1YS0zZSw8ZShBZyhBaSpEaDhIbDVLbytPbiZMdjFKeTxWgEZlglhkjE5wjDJrh11ti1l1j0Bzkl96jW57kG13lWh4lWeBnTeFoEmEn2+Jo3aesWqqsVehrZbH0LzJz8HW3M7Y3NPk6ODt7+rv8O7y8/BQn9+1AAABp0lEQVR42lWSVXMbMRRGBatFe3nXzMwOcxyww8xpUkjKDacQKP31al3vJD4PmtF3NCPdewVAh76N6/n3V6m+QdBFz9JcspZK1SqepZ5n8aEdTdTrqc3Nbxv1ZLz06OYD8ejHWqWSzGS+nCe/JuLS/f/8lxSNJ2zbvs3AM6tkJ5pR6bAtSpLU9FAyEPrezHo8c5I07+S7rKZNx2Kx75DyqaHFpjWNdV4wy7Ks1lq52XeEv7zSonv2Hb1ZZMtbaejSC2F6qyyKB2BNFN/6YBe+V6FwFXwWxdDLLuMbN0joA7AmGyES8T/l/oiiEGQBKzxpqvjJrEdkGaumBRaOwmEkGNuu2OZlQ0DmAqiOmeYEEvpdkeZlgibGLsFBEFGO22LdWXKKgFBwD4CCY06oSK+u/qBljMsCCr6gle+Mqqo60+tfzjFMbnkfnvJEHV1zmvV6RBCKxSGmzVBxhsMjhXZ3f2azROG8XobjeY7xejk9MNAZdzYgczRWMFZ4ekLfdUf4UNB1fhgTQrChc/m9Zx+imh82MCUQyF/86foof+8WpwieWtz53Qn+AVE4OsMepx4GAAAAAElFTkSuQmCC";
      }
    </script>
    <meta name="savepage-url" content="https://docs.spring.io/spring/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html">
    <meta name="savepage-title" content="11. Aspect Oriented Programming with Spring">
    <meta name="savepage-date" content="Tue Jul 30 2019 12:32:26 GMT+0300 (Москва, стандартное время)">
    <meta name="savepage-state" content="Standard Items; Used resource loader; Retained cross-origin frames; Removed unsaved URLs; Max frame depth = 5; Max resource size = 50MB; Max resource time = 10s;">
    <meta name="savepage-version" content="15.1">
    <meta name="savepage-comments" content="">
    <meta name="savepage-resourceloader" content=""></head><body vlink="#840084" text="black" link="#0000FF" bgcolor="white" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tbody><tr><th colspan="3" align="center">11. Aspect Oriented Programming with Spring</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="expressions.html">Prev</a> </td><th width="60%" align="center">Part III. Core Technologies</th><td width="20%" align="right"> <a accesskey="n" href="aop-api.html">Next</a></td></tr></tbody></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="aop" href="#aop"></a>11. Aspect Oriented Programming with Spring</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction" href="#aop-introduction"></a>11.1 Introduction</h2></div></div></div>
<p><span class="emphasis"><em>Aspect-Oriented Programming</em></span> (AOP) complements Object-Oriented Programming (OOP) by
providing another way of thinking about program structure. The key unit of modularity in
OOP is the class, whereas in AOP the unit of modularity is the <span class="emphasis"><em>aspect</em></span>. Aspects
enable the modularization of concerns such as transaction management that cut across
multiple types and objects. (Such concerns are often termed <span class="emphasis"><em>crosscutting</em></span> concerns in
AOP literature.)</p>
<p>One of the key components of Spring is the <span class="emphasis"><em>AOP framework</em></span>. While the Spring IoC
container does not depend on AOP, meaning you do not need to use AOP if you don’t want
to, AOP complements Spring IoC to provide a very capable middleware solution.</p>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>Spring 2.0 AOP</b></p></div></div></div>
<p>Spring 2.0 introduces a simpler and more powerful way of writing custom aspects using
either a <a class="link" href="aop.html#aop-schema" title="11.3 Schema-based AOP support">schema-based approach</a> or the <a class="link" href="aop.html#aop-ataspectj" title="11.2 @AspectJ support">@AspectJ annotation
style</a>. Both of these styles offer fully typed advice and use of the AspectJ pointcut
language, while still using Spring AOP for weaving.</p>
<p>The Spring 2.0 schema- and @AspectJ-based AOP support is discussed in this chapter.
Spring 2.0 AOP remains fully backwards compatible with Spring 1.2 AOP, and the
lower-level AOP support offered by the Spring 1.2 APIs is discussed in <a class="link" href="aop-api.html" title="12. Spring AOP APIs">the
following chapter</a>.</p>
</div>
<p>AOP is used in the Spring Framework to…​</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
…​ provide declarative enterprise services, especially as a replacement for EJB
declarative services. The most important such service is
<a class="link" href="transaction.html#transaction-declarative" title="17.5 Declarative transaction management"><span class="emphasis"><em>declarative transaction management</em></span></a>.
</li><li class="listitem">
…​ allow users to implement custom aspects, complementing their use of OOP with AOP.
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>If you are interested only in generic declarative services or other pre-packaged
declarative middleware services such as pooling, you do not need to work directly with
Spring AOP, and can skip most of this chapter.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn" href="#aop-introduction-defn"></a>11.1.1 AOP concepts</h3></div></div></div>
<p>Let us begin by defining some central AOP concepts and terminology. These terms are not
Spring-specific…​ unfortunately, AOP terminology is not particularly intuitive;
however, it would be even more confusing if Spring used its own terminology.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>Aspect</em></span>: a modularization of a concern that cuts across multiple classes.
Transaction management is a good example of a crosscutting concern in enterprise Java
applications. In Spring AOP, aspects are implemented using regular classes
(the <a class="link" href="aop.html#aop-schema" title="11.3 Schema-based AOP support">schema-based approach</a>) or regular classes annotated with the
<code class="literal">@Aspect</code> annotation (the <a class="link" href="aop.html#aop-ataspectj" title="11.2 @AspectJ support"><code class="literal">@AspectJ</code> style</a>).
</li><li class="listitem">
<span class="emphasis"><em>Join point</em></span>: a point during the execution of a program, such as the execution of a
method or the handling of an exception. In Spring AOP, a join point <span class="emphasis"><em>always</em></span>
represents a method execution.
</li><li class="listitem">
<span class="emphasis"><em>Advice</em></span>: action taken by an aspect at a particular join point. Different types of
advice include "around," "before" and "after" advice. (Advice types are discussed
below.) Many AOP frameworks, including Spring, model an advice as an <span class="emphasis"><em>interceptor</em></span>,
maintaining a chain of interceptors <span class="emphasis"><em>around</em></span> the join point.
</li><li class="listitem">
<span class="emphasis"><em>Pointcut</em></span>: a predicate that matches join points. Advice is associated with a
pointcut expression and runs at any join point matched by the pointcut (for example,
the execution of a method with a certain name). The concept of join points as matched
by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut
expression language by default.
</li><li class="listitem">
<span class="emphasis"><em>Introduction</em></span>: declaring additional methods or fields on behalf of a type. Spring
AOP allows you to introduce new interfaces (and a corresponding implementation) to any
advised object. For example, you could use an introduction to make a bean implement an
<code class="literal">IsModified</code> interface, to simplify caching. (An introduction is known as an
inter-type declaration in the AspectJ community.)
</li><li class="listitem">
<span class="emphasis"><em>Target object</em></span>: object being advised by one or more aspects. Also referred to as
the <span class="emphasis"><em>advised</em></span> object. Since Spring AOP is implemented using runtime proxies, this
object will always be a <span class="emphasis"><em>proxied</em></span> object.
</li><li class="listitem">
<span class="emphasis"><em>AOP proxy</em></span>: an object created by the AOP framework in order to implement the aspect
contracts (advise method executions and so on). In the Spring Framework, an AOP proxy
will be a JDK dynamic proxy or a CGLIB proxy.
</li><li class="listitem">
<span class="emphasis"><em>Weaving</em></span>: linking aspects with other application types or objects to create an
advised object. This can be done at compile time (using the AspectJ compiler, for
example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks,
performs weaving at runtime.
</li></ul></div>
<p>Types of advice:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>Before advice</em></span>: Advice that executes before a join point, but which does not have
the ability to prevent execution flow proceeding to the join point (unless it throws
an exception).
</li><li class="listitem">
<span class="emphasis"><em>After returning advice</em></span>: Advice to be executed after a join point completes
normally: for example, if a method returns without throwing an exception.
</li><li class="listitem">
<span class="emphasis"><em>After throwing advice</em></span>: Advice to be executed if a method exits by throwing an
exception.
</li><li class="listitem">
<span class="emphasis"><em>After (finally) advice</em></span>: Advice to be executed regardless of the means by which a
join point exits (normal or exceptional return).
</li><li class="listitem">
<span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a join point such as a method invocation.
This is the most powerful kind of advice. Around advice can perform custom behavior
before and after the method invocation. It is also responsible for choosing whether to
proceed to the join point or to shortcut the advised method execution by returning its
own return value or throwing an exception.
</li></ul></div>
<p>Around advice is the most general kind of advice. Since Spring AOP, like AspectJ,
provides a full range of advice types, we recommend that you use the least powerful
advice type that can implement the required behavior. For example, if you need only to
update a cache with the return value of a method, you are better off implementing an
after returning advice than an around advice, although an around advice can accomplish
the same thing. Using the most specific advice type provides a simpler programming model
with less potential for errors. For example, you do not need to invoke the <code class="literal">proceed()</code>
method on the <code class="literal">JoinPoint</code> used for around advice, and hence cannot fail to invoke it.</p>
<p>In Spring 2.0, all advice parameters are statically typed, so that you work with advice
parameters of the appropriate type (the type of the return value from a method execution
for example) rather than <code class="literal">Object</code> arrays.</p>
<p>The concept of join points, matched by pointcuts, is the key to AOP which distinguishes
it from older technologies offering only interception. Pointcuts enable advice to be
targeted independently of the Object-Oriented hierarchy. For example, an around advice
providing declarative transaction management can be applied to a set of methods spanning
multiple objects (such as all business operations in the service layer).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn" href="#aop-introduction-spring-defn"></a>11.1.2 Spring AOP capabilities and goals</h3></div></div></div>
<p>Spring AOP is implemented in pure Java. There is no need for a special compilation
process. Spring AOP does not need to control the class loader hierarchy, and is thus
suitable for use in a Servlet container or application server.</p>
<p>Spring AOP currently supports only method execution join points (advising the execution
of methods on Spring beans). Field interception is not implemented, although support for
field interception could be added without breaking the core Spring AOP APIs. If you need
to advise field access and update join points, consider a language such as AspectJ.</p>
<p>Spring AOP’s approach to AOP differs from that of most other AOP frameworks. The aim is
not to provide the most complete AOP implementation (although Spring AOP is quite
capable); it is rather to provide a close integration between AOP implementation and
Spring IoC to help solve common problems in enterprise applications.</p>
<p>Thus, for example, the Spring Framework’s AOP functionality is normally used in
conjunction with the Spring IoC container. Aspects are configured using normal bean
definition syntax (although this allows powerful "autoproxying" capabilities): this is a
crucial difference from other AOP implementations. There are some things you cannot do
easily or efficiently with Spring AOP, such as advise very fine-grained objects (such as
domain objects typically): AspectJ is the best choice in such cases. However, our
experience is that Spring AOP provides an excellent solution to most problems in
enterprise Java applications that are amenable to AOP.</p>
<p>Spring AOP will never strive to compete with AspectJ to provide a comprehensive AOP
solution. We believe that both proxy-based frameworks like Spring AOP and full-blown
frameworks such as AspectJ are valuable, and that they are complementary, rather than in
competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable
all uses of AOP to be catered for within a consistent Spring-based application
architecture. This integration does not affect the Spring AOP API or the AOP Alliance
API: Spring AOP remains backward-compatible. See <a class="link" href="aop-api.html" title="12. Spring AOP APIs">the following chapter</a> for a
discussion of the Spring AOP APIs.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>One of the central tenets of the Spring Framework is that of <span class="emphasis"><em>non-invasiveness</em></span>; this
is the idea that you should not be forced to introduce framework-specific classes and
interfaces into your business/domain model. However, in some places the Spring Framework
does give you the option to introduce Spring Framework-specific dependencies into your
codebase: the rationale in giving you such options is because in certain scenarios it
might be just plain easier to read or code some specific piece of functionality in such
a way. The Spring Framework (almost) always offers you the choice though: you have the
freedom to make an informed decision as to which option best suits your particular use
case or scenario.</p>
<p>One such choice that is relevant to this chapter is that of which AOP framework (and
which AOP style) to choose. You have the choice of AspectJ and/or Spring AOP, and you
also have the choice of either the @AspectJ annotation-style approach or the Spring XML
configuration-style approach. The fact that this chapter chooses to introduce the
@AspectJ-style approach first should not be taken as an indication that the Spring team
favors the @AspectJ annotation-style approach over the Spring XML configuration-style.</p>
<p>See <a class="xref" href="aop.html#aop-choosing" title="11.4 Choosing which AOP declaration style to use">Section 11.4, “Choosing which AOP declaration style to use”</a> for a more complete discussion of the whys and wherefores of each
style.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies" href="#aop-introduction-proxies"></a>11.1.3 AOP Proxies</h3></div></div></div>
<p>Spring AOP defaults to using standard JDK <span class="emphasis"><em>dynamic proxies</em></span> for AOP proxies. This
enables any interface (or set of interfaces) to be proxied.</p>
<p>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than
interfaces. CGLIB is used by default if a business object does not implement an
interface. As it is good practice to program to interfaces rather than classes; business
classes normally will implement one or more business interfaces. It is possible to
<a class="link" href="aop.html#aop-proxying" title="11.6 Proxying mechanisms">force the use of CGLIB</a>, in those (hopefully rare) cases where you
need to advise a method that is not declared on an interface, or where you need to
pass a proxied object to a method as a concrete type.</p>
<p>It is important to grasp the fact that Spring AOP is <span class="emphasis"><em>proxy-based</em></span>. See
<a class="xref" href="aop.html#aop-understanding-aop-proxies" title="11.6.1 Understanding AOP proxies">Section 11.6.1, “Understanding AOP proxies”</a> for a thorough examination of exactly what this
implementation detail actually means.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-ataspectj" href="#aop-ataspectj"></a>11.2 @AspectJ support</h2></div></div></div>
<p>@AspectJ refers to a style of declaring aspects as regular Java classes annotated with
annotations. The @AspectJ style was introduced by the
<a class="ulink" href="https://www.eclipse.org/aspectj" target="_top">AspectJ project</a> as part of the AspectJ 5 release. Spring
interprets the same annotations as AspectJ 5, using a library supplied by AspectJ
for pointcut parsing and matching. The AOP runtime is still pure Spring AOP though, and
there is no dependency on the AspectJ compiler or weaver.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Using the AspectJ compiler and weaver enables use of the full AspectJ language, and is
discussed in <a class="xref" href="aop.html#aop-using-aspectj" title="11.8 Using AspectJ with Spring applications">Section 11.8, “Using AspectJ with Spring applications”</a>.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aspectj-support" href="#aop-aspectj-support"></a>11.2.1 Enabling @AspectJ Support</h3></div></div></div>
<p>To use @AspectJ aspects in a Spring configuration you need to enable Spring support for
configuring Spring AOP based on @AspectJ aspects, and <span class="emphasis"><em>autoproxying</em></span> beans based on
whether or not they are advised by those aspects. By autoproxying we mean that if Spring
determines that a bean is advised by one or more aspects, it will automatically generate
a proxy for that bean to intercept method invocations and ensure that advice is executed
as needed.</p>
<p>The @AspectJ support can be enabled with XML or Java style configuration. In either
case you will also need to ensure that AspectJ’s <code class="literal">aspectjweaver.jar</code> library is on the
classpath of your application (version 1.6.8 or later). This library is available in the
<code class="literal">'lib'</code> directory of an AspectJ distribution or via the Maven Central repository.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-enable-aspectj-java" href="#aop-enable-aspectj-java"></a>Enabling @AspectJ Support with Java configuration</h4></div></div></div>
<p>To enable @AspectJ support with Java <code class="literal">@Configuration</code> add the <code class="literal">@EnableAspectJAutoProxy</code>
annotation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAspectJAutoProxy</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-enable-aspectj-xml" href="#aop-enable-aspectj-xml"></a>Enabling @AspectJ Support with XML configuration</h4></div></div></div>
<p>To enable @AspectJ support with XML based configuration use the <code class="literal">aop:aspectj-autoproxy</code>
element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy/&gt;</span></pre>
<p>This assumes that you are using schema support as described in <a class="xref" href="xsd-configuration.html" title="41. XML Schema-based configuration">Chapter 41, <i>XML Schema-based configuration</i></a>. See
<a class="xref" href="xsd-configuration.html#xsd-config-body-schemas-aop" title="41.2.7 the aop schema">Section 41.2.7, “the aop schema”</a> for how to import the tags in the <code class="literal">aop</code> namespace.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-at-aspectj" href="#aop-at-aspectj"></a>11.2.2 Declaring an aspect</h3></div></div></div>
<p>With the @AspectJ support enabled, any bean defined in your application context with a
class that is an @AspectJ aspect (has the <code class="literal">@Aspect</code> annotation) will be automatically
detected by Spring and used to configure Spring AOP. The following example shows the
minimal definition required for a not-very-useful aspect:</p>
<p>A regular bean definition in the application context, pointing to a bean class that has
the <code class="literal">@Aspect</code> annotation:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.xyz.NotVeryUsefulAspect"</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- configure properties of aspect here as normal --&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>And the <code class="literal">NotVeryUsefulAspect</code> class definition, annotated with
<code class="literal">org.aspectj.lang.annotation.Aspect</code> annotation;</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.xyz;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> NotVeryUsefulAspect {

}</pre>
<p>Aspects (classes annotated with <code class="literal">@Aspect</code>) may have methods and fields just like any
other class. They may also contain pointcut, advice, and introduction (inter-type)
declarations.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note: Autodetecting aspects through component scanning" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Autodetecting aspects through component scanning</th></tr><tr><td valign="top" align="left">
<p>You may register aspect classes as regular beans in your Spring XML configuration, or
autodetect them through classpath scanning - just like any other Spring-managed bean.
However, note that the <span class="emphasis"><em>@Aspect</em></span> annotation is <span class="emphasis"><em>not</em></span> sufficient for autodetection in
the classpath: For that purpose, you need to add a separate <span class="emphasis"><em>@Component</em></span> annotation
(or alternatively a custom stereotype annotation that qualifies, as per the rules of
Spring’s component scanner).</p>
</td></tr></tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note: Advising aspects with other aspects?" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Advising aspects with other aspects?</th></tr><tr><td valign="top" align="left">
<p>In Spring AOP, it is <span class="emphasis"><em>not</em></span> possible to have aspects themselves be the target of advice
from other aspects. The <span class="emphasis"><em>@Aspect</em></span> annotation on a class marks it as an aspect, and
hence excludes it from auto-proxying.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pointcuts" href="#aop-pointcuts"></a>11.2.3 Declaring a pointcut</h3></div></div></div>
<p>Recall that pointcuts determine join points of interest, and thus enable us to control
when advice executes. <span class="emphasis"><em>Spring AOP only supports method execution join points for Spring
beans</em></span>, so you can think of a pointcut as matching the execution of methods on Spring
beans. A pointcut declaration has two parts: a signature comprising a name and any
parameters, and a pointcut expression that determines <span class="emphasis"><em>exactly</em></span> which method
executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut
signature is provided by a regular method definition, and the pointcut expression is
indicated using the <code class="literal">@Pointcut</code> annotation (the method serving as the pointcut signature
<span class="emphasis"><em>must</em></span> have a <code class="literal">void</code> return type).</p>
<p>An example will help make this distinction between a pointcut signature and a pointcut
expression clear. The following example defines a pointcut named <code class="literal">'anyOldTransfer'</code> that
will match the execution of any method named <code class="literal">'transfer'</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Pointcut("execution(* transfer(..))")//</span></em> the pointcut expression
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> anyOldTransfer() {}<span class="hl-comment">// the pointcut signature</span></pre>
<p>The pointcut expression that forms the value of the <code class="literal">@Pointcut</code> annotation is a regular
AspectJ 5 pointcut expression. For a full discussion of AspectJ’s pointcut language, see
the <a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_top">AspectJ
Programming Guide</a> (and for extensions, the
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html" target="_top">AspectJ 5
Developers Notebook</a>) or one of the books on AspectJ such as "Eclipse AspectJ" by Colyer
et. al. or "AspectJ in Action" by Ramnivas Laddad.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-designators" href="#aop-pointcuts-designators"></a>Supported Pointcut Designators</h4></div></div></div>
<p>Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
expressions:</p>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>Other pointcut types</b></p></div></div></div>
<p>The full AspectJ pointcut language supports additional pointcut designators that are not
supported in Spring. These are: <code class="literal">call, get, set, preinitialization,
staticinitialization, initialization, handler, adviceexecution, withincode, cflow,
cflowbelow, if, @this</code>, and <code class="literal">@withincode</code>. Use of these pointcut designators in pointcut
expressions interpreted by Spring AOP will result in an <code class="literal">IllegalArgumentException</code> being
thrown.</p>
<p>The set of pointcut designators supported by Spring AOP may be extended in future
releases to support more of the AspectJ pointcut designators.</p>
</div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>execution</em></span> - for matching method execution join points, this is the primary
pointcut designator you will use when working with Spring AOP
</li><li class="listitem">
<span class="emphasis"><em>within</em></span> - limits matching to join points within certain types (simply the execution
of a method declared within a matching type when using Spring AOP)
</li><li class="listitem">
<span class="emphasis"><em>this</em></span> - limits matching to join points (the execution of methods when using Spring
AOP) where the bean reference (Spring AOP proxy) is an instance of the given type
</li><li class="listitem">
<span class="emphasis"><em>target</em></span> - limits matching to join points (the execution of methods when using
Spring AOP) where the target object (application object being proxied) is an instance
of the given type
</li><li class="listitem">
<span class="emphasis"><em>args</em></span> - limits matching to join points (the execution of methods when using Spring
AOP) where the arguments are instances of the given types
</li><li class="listitem">
<span class="emphasis"><em>@target</em></span> - limits matching to join points (the execution of methods when using
Spring AOP) where the class of the executing object has an annotation of the given type
</li><li class="listitem">
<span class="emphasis"><em>@args</em></span> - limits matching to join points (the execution of methods when using Spring
AOP) where the runtime type of the actual arguments passed have annotations of the
given type(s)
</li><li class="listitem">
<span class="emphasis"><em>@within</em></span> - limits matching to join points within types that have the given
annotation (the execution of methods declared in types with the given annotation when
using Spring AOP)
</li><li class="listitem">
<span class="emphasis"><em>@annotation</em></span> - limits matching to join points where the subject of the join point
(method being executed in Spring AOP) has the given annotation
</li></ul></div>
<p>Because Spring AOP limits matching to only method execution join points, the discussion
of the pointcut designators above gives a narrower definition than you will find in the
AspectJ programming guide. In addition, AspectJ itself has type-based semantics and at
an execution join point both <code class="literal">this</code> and <code class="literal">target</code> refer to the same object - the
object executing the method. Spring AOP is a proxy-based system and differentiates
between the proxy object itself (bound to <code class="literal">this</code>) and the target object behind the
proxy (bound to <code class="literal">target</code>).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Due to the proxy-based nature of Spring’s AOP framework, calls within the target object
are by definition <span class="emphasis"><em>not</em></span> intercepted. For JDK proxies, only public interface method
calls on the proxy can be intercepted. With CGLIB, public and protected method calls on
the proxy will be intercepted, and even package-visible methods if necessary. However,
common interactions through proxies should always be designed through public signatures.</p>
<p>Note that pointcut definitions are generally matched against any intercepted method.
If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with
potential non-public interactions through proxies, it needs to be defined accordingly.</p>
<p>If your interception needs include method calls or even constructors within the target
class, consider the use of Spring-driven <a class="link" href="aop.html#aop-aj-ltw" title="11.8.4 Load-time weaving with AspectJ in the Spring Framework">native AspectJ weaving</a> instead
of Spring’s proxy-based AOP framework. This constitutes a different mode of AOP usage
with different characteristics, so be sure to make yourself familiar with weaving first
before making a decision.</p>
</td></tr></tbody></table></div>
<p>Spring AOP also supports an additional PCD named <code class="literal">bean</code>. This PCD allows you to limit
the matching of join points to a particular named Spring bean, or to a set of named
Spring beans (when using wildcards). The <code class="literal">bean</code> PCD has the following form:</p>
<pre class="programlisting">bean(idOrNameOfBean)</pre>
<p>The <code class="literal">idOrNameOfBean</code> token can be the name of any Spring bean: limited wildcard
support using the <code class="literal">*</code> character is provided, so if you establish some naming
conventions for your Spring beans you can quite easily write a <code class="literal">bean</code> PCD expression
to pick them out. As is the case with other pointcut designators, the <code class="literal">bean</code> PCD can
be &amp;&amp;'ed, ||'ed, and ! (negated) too.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Please note that the <code class="literal">bean</code> PCD is <span class="emphasis"><em>only</em></span> supported in Spring AOP - and <span class="emphasis"><em>not</em></span> in
native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that
AspectJ defines and therefore not available for aspects declared in the <code class="literal">@Aspect</code> model.</p>
<p>The <code class="literal">bean</code> PCD operates at the <span class="emphasis"><em>instance</em></span> level (building on the Spring bean name
concept) rather than at the type level only (which is what weaving-based AOP is limited
to). Instance-based pointcut designators are a special capability of Spring’s
proxy-based AOP framework and its close integration with the Spring bean factory, where
it is natural and straightforward to identify specific beans by name.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-combining" href="#aop-pointcuts-combining"></a>Combining pointcut expressions</h4></div></div></div>
<p>Pointcut expressions can be combined using '&amp;&amp;', '||' and '!'. It is also possible to
refer to pointcut expressions by name. The following example shows three pointcut
expressions: <code class="literal">anyPublicOperation</code> (which matches if a method execution join point
represents the execution of any public method); <code class="literal">inTrading</code> (which matches if a method
execution is in the trading module), and <code class="literal">tradingOperation</code> (which matches if a method
execution represents any public method in the trading module).</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Pointcut("execution(public * *(..))")</span></em>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> anyPublicOperation() {}

<em><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.trading..*)")</span></em>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> inTrading() {}

<em><span class="hl-annotation" style="color: gray">@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")</span></em>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> tradingOperation() {}</pre>
<p>It is a best practice to build more complex pointcut expressions out of smaller named
components as shown above. When referring to pointcuts by name, normal Java visibility
rules apply (you can see private pointcuts in the same type, protected pointcuts in the
hierarchy, public pointcuts anywhere and so on). Visibility does not affect pointcut
<span class="emphasis"><em>matching</em></span>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-common-pointcuts" href="#aop-common-pointcuts"></a>Sharing common pointcut definitions</h4></div></div></div>
<p>When working with enterprise applications, you often want to refer to modules of the
application and particular sets of operations from within several aspects. We recommend
defining a "SystemArchitecture" aspect that captures common pointcut expressions for
this purpose. A typical such aspect would look as follows:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.someapp;

<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Pointcut;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SystemArchitecture {

    <strong class="hl-tag" style="color: blue">/**
     * A join point is in the web layer if the method is defined
     * in a type in the com.xyz.someapp.web package or any sub-package
     * under that.
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.web..*)")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inWebLayer() {}

    <strong class="hl-tag" style="color: blue">/**
     * A join point is in the service layer if the method is defined
     * in a type in the com.xyz.someapp.service package or any sub-package
     * under that.
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.service..*)")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inServiceLayer() {}

    <strong class="hl-tag" style="color: blue">/**
     * A join point is in the data access layer if the method is defined
     * in a type in the com.xyz.someapp.dao package or any sub-package
     * under that.
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.dao..*)")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inDataAccessLayer() {}

    <strong class="hl-tag" style="color: blue">/**
     * A business service is the execution of any method defined on a service
     * interface. This definition assumes that interfaces are placed in the
     * "service" package, and that implementation types are in sub-packages.
     *
     * If you group service interfaces by functional area (for example,
     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
     * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
     * could be used instead.
     *
     * Alternatively, you can write the expression using the 'bean'
     * PCD, like so "bean(*Service)". (This assumes that you have
     * named your Spring service beans in a consistent fashion.)
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Pointcut("execution(* com.xyz.someapp..service.*.*(..))")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> businessService() {}

    <strong class="hl-tag" style="color: blue">/**
     * A data access operation is the execution of any method defined on a
     * dao interface. This definition assumes that interfaces are placed in the
     * "dao" package, and that implementation types are in sub-packages.
     */</strong>
    <em><span class="hl-annotation" style="color: gray">@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> dataAccessOperation() {}

}</pre>
<p>The pointcuts defined in such an aspect can be referred to anywhere that you need a
pointcut expression. For example, to make the service layer transactional, you could
write:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
    <span class="hl-tag">&lt;aop:advisor</span>
        <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.someapp.SystemArchitecture.businessService()"</span>
        <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;tx:attributes&gt;</span>
        <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>
<p>The <code class="literal">&lt;aop:config&gt;</code> and <code class="literal">&lt;aop:advisor&gt;</code> elements are discussed in <a class="xref" href="aop.html#aop-schema" title="11.3 Schema-based AOP support">Section 11.3, “Schema-based AOP support”</a>. The
transaction elements are discussed in <a class="xref" href="transaction.html" title="17. Transaction Management">Chapter 17, <i>Transaction Management</i></a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-examples" href="#aop-pointcuts-examples"></a>Examples</h4></div></div></div>
<p>Spring AOP users are likely to use the <code class="literal">execution</code> pointcut designator the most often.
The format of an execution expression is:</p>
<pre class="programlisting">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
            <span class="hl-keyword">throws</span>-pattern?)</pre>
<p>All parts except the returning type pattern (ret-type-pattern in the snippet above),
name pattern, and parameters pattern are optional. The returning type pattern determines
what the return type of the method must be in order for a join point to be matched. Most
frequently you will use <code class="literal">*</code> as the returning type pattern, which matches any return
type. A fully-qualified type name will match only when the method returns the given
type. The name pattern matches the method name. You can use the <code class="literal">*</code> wildcard as all or
part of a name pattern. If specifying a declaring type pattern
then include a trailing <code class="literal">.</code> to join it to the name pattern component.
The parameters pattern is slightly more complex: <code class="literal">()</code> matches a
method that takes no parameters, whereas <code class="literal">(..)</code> matches any number of parameters (zero
or more). The pattern <code class="literal">(*)</code> matches a method taking one parameter of any type,
<code class="literal">(*,String)</code> matches a method taking two parameters, the first can be of any type, the
second must be a String. Consult the
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html" target="_top">Language
Semantics</a> section of the AspectJ Programming Guide for more information.</p>
<p>Some examples of common pointcut expressions are given below.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the execution of any public method:
</li></ul></div>
<pre class="programlisting">execution(<span class="hl-keyword">public</span> * *(..))</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the execution of any method with a name beginning with "set":
</li></ul></div>
<pre class="programlisting">execution(* set*(..))</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the execution of any method defined by the <code class="literal">AccountService</code> interface:
</li></ul></div>
<pre class="programlisting">execution(* com.xyz.service.AccountService.*(..))</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the execution of any method defined in the service package:
</li></ul></div>
<pre class="programlisting">execution(* com.xyz.service.*.*(..))</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the execution of any method defined in the service package or a sub-package:
</li></ul></div>
<pre class="programlisting">execution(* com.xyz.service..*.*(..))</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) within the service package:
</li></ul></div>
<pre class="programlisting">within(com.xyz.service.*)</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) within the service package or a
sub-package:
</li></ul></div>
<pre class="programlisting">within(com.xyz.service..*)</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) where the proxy implements the
<code class="literal">AccountService</code> interface:
</li></ul></div>
<pre class="programlisting"><span class="hl-keyword">this</span>(com.xyz.service.AccountService)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'this' is more commonly used in a binding form :- see the following section on advice
for how to make the proxy object available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) where the target object
implements the <code class="literal">AccountService</code> interface:
</li></ul></div>
<pre class="programlisting">target(com.xyz.service.AccountService)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'target' is more commonly used in a binding form :- see the following section on advice
for how to make the target object available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) which takes a single parameter,
and where the argument passed at runtime is <code class="literal">Serializable</code>:
</li></ul></div>
<pre class="programlisting">args(java.io.Serializable)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'args' is more commonly used in a binding form :- see the following section on advice
for how to make the method arguments available in the advice body.</p>
</td></tr></tbody></table></div>
<p>Note that the pointcut given in this example is different to <code class="literal">execution(*
*(java.io.Serializable))</code>: the args version matches if the argument passed at runtime is
Serializable, the execution version matches if the method signature declares a single
parameter of type <code class="literal">Serializable</code>.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) where the target object has an
<code class="literal">@Transactional</code> annotation:
</li></ul></div>
<pre class="programlisting">@target(org.springframework.transaction.annotation.Transactional)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'@target' can also be used in a binding form :- see the following section on advice for
how to make the annotation object available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) where the declared type of the
target object has an <code class="literal">@Transactional</code> annotation:
</li></ul></div>
<pre class="programlisting">@within(org.springframework.transaction.annotation.Transactional)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'@within' can also be used in a binding form :- see the following section on advice for
how to make the annotation object available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) where the executing method has an
<code class="literal">@Transactional</code> annotation:
</li></ul></div>
<pre class="programlisting">@annotation(org.springframework.transaction.annotation.Transactional)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'@annotation' can also be used in a binding form :- see the following section on advice
for how to make the annotation object available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) which takes a single parameter,
and where the runtime type of the argument passed has the <code class="literal">@Classified</code> annotation:
</li></ul></div>
<pre class="programlisting">@args(com.xyz.security.Classified)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>'@args' can also be used in a binding form :- see the following section on advice for
how to make the annotation object(s) available in the advice body.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) on a Spring bean named
<code class="literal">tradeService</code>:
</li></ul></div>
<pre class="programlisting">bean(tradeService)</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
any join point (method execution only in Spring AOP) on Spring beans having names that
match the wildcard expression <code class="literal">*Service</code>:
</li></ul></div>
<pre class="programlisting">bean(*Service)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="writing-good-pointcuts" href="#writing-good-pointcuts"></a>Writing good pointcuts</h4></div></div></div>
<p>During compilation, AspectJ processes pointcuts in order to try and optimize matching
performance. Examining code and determining if each join point matches (statically or
dynamically) a given pointcut is a costly process. (A dynamic match means the match
cannot be fully determined from static analysis and a test will be placed in the code to
determine if there is an actual match when the code is running). On first encountering a
pointcut declaration, AspectJ will rewrite it into an optimal form for the matching
process. What does this mean? Basically pointcuts are rewritten in DNF (Disjunctive
Normal Form) and the components of the pointcut are sorted such that those components
that are cheaper to evaluate are checked first. This means you do not have to worry
about understanding the performance of various pointcut designators and may supply them
in any order in a pointcut declaration.</p>
<p>However, AspectJ can only work with what it is told, and for optimal performance of
matching you should think about what they are trying to achieve and narrow the search
space for matches as much as possible in the definition. The existing designators
naturally fall into one of three groups: kinded, scoping and context:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Kinded designators are those which select a particular kind of join point. For
example: execution, get, set, call, handler
</li><li class="listitem">
Scoping designators are those which select a group of join points of interest (of
probably many kinds). For example: within, withincode
</li><li class="listitem">
Contextual designators are those that match (and optionally bind) based on context.
For example: this, target, @annotation
</li></ul></div>
<p>A well written pointcut should try and include at least the first two types (kinded and
scoping), whilst the contextual designators may be included if wishing to match based on
join point context, or bind that context for use in the advice. Supplying either just a
kinded designator or just a contextual designator will work but could affect weaving
performance (time and memory used) due to all the extra processing and analysis. Scoping
designators are very fast to match and their usage means AspectJ can very quickly
dismiss groups of join points that should not be further processed - that is why a good
pointcut should always include one if possible.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-advice" href="#aop-advice"></a>11.2.4 Declaring advice</h3></div></div></div>
<p>Advice is associated with a pointcut expression, and runs before, after, or around
method executions matched by the pointcut. The pointcut expression may be either a
simple reference to a named pointcut, or a pointcut expression declared in place.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-before" href="#aop-advice-before"></a>Before advice</h4></div></div></div>
<p>Before advice is declared in an aspect using the <code class="literal">@Before</code> annotation:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Before;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BeforeExample {

    <em><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<p>If using an in-place pointcut expression we could rewrite the above example as:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Before;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BeforeExample {

    <em><span class="hl-annotation" style="color: gray">@Before("execution(* com.xyz.myapp.dao.*.*(..))")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-returning" href="#aop-advice-after-returning"></a>After returning advice</h4></div></div></div>
<p>After returning advice runs when a matched method execution returns normally. It is
declared using the <code class="literal">@AfterReturning</code> annotation:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterReturningExample {

    <em><span class="hl-annotation" style="color: gray">@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Note: it is of course possible to have multiple advice declarations, and other members
as well, all inside the same aspect. We’re just showing a single advice declaration in
these examples to focus on the issue under discussion at the time.</p>
</td></tr></tbody></table></div>
<p>Sometimes you need access in the advice body to the actual value that was returned. You
can use the form of <code class="literal">@AfterReturning</code> that binds the return value for this:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterReturningExample {

    <em><span class="hl-annotation" style="color: gray">@AfterReturning(
        pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
        returning="retVal")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck(Object retVal) {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<p>The name used in the <code class="literal">returning</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution returns, the return value will be passed to
the advice method as the corresponding argument value. A <code class="literal">returning</code> clause also
restricts matching to only those method executions that return a value of the specified
type ( <code class="literal">Object</code> in this case, which will match any return value).</p>
<p>Please note that it is <span class="emphasis"><em>not</em></span> possible to return a totally different reference when
using after-returning advice.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-throwing" href="#aop-advice-after-throwing"></a>After throwing advice</h4></div></div></div>
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. It is declared using the <code class="literal">@AfterThrowing</code> annotation:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterThrowingExample {

    <em><span class="hl-annotation" style="color: gray">@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<p>Often you want the advice to run only when exceptions of a given type are thrown, and
you also often need access to the thrown exception in the advice body. Use the
<code class="literal">throwing</code> attribute to both restrict matching (if desired, use <code class="literal">Throwable</code> as the
exception type otherwise) and bind the thrown exception to an advice parameter.</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterThrowingExample {

    <em><span class="hl-annotation" style="color: gray">@AfterThrowing(
        pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
        throwing="ex")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions(DataAccessException ex) {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<p>The name used in the <code class="literal">throwing</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution exits by throwing an exception, the exception
will be passed to the advice method as the corresponding argument value. A <code class="literal">throwing</code>
clause also restricts matching to only those method executions that throw an exception
of the specified type ( <code class="literal">DataAccessException</code> in this case).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-finally" href="#aop-advice-after-finally"></a>After (finally) advice</h4></div></div></div>
<p>After (finally) advice runs however a matched method execution exits. It is declared
using the <code class="literal">@After</code> annotation. After advice must be prepared to handle both normal and
exception return conditions. It is typically used for releasing resources, etc.</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.After;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterFinallyExample {

    <em><span class="hl-annotation" style="color: gray">@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doReleaseLock() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-around-advice" href="#aop-ataspectj-around-advice"></a>Around advice</h4></div></div></div>
<p>The final kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method executes,
and to determine when, how, and even if, the method actually gets to execute at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer for example). Always
use the least powerful form of advice that meets your requirements (i.e. don’t use
around advice if simple before advice would do).</p>
<p>Around advice is declared using the <code class="literal">@Around</code> annotation. The first parameter of the
advice method must be of type <code class="literal">ProceedingJoinPoint</code>. Within the body of the advice,
calling <code class="literal">proceed()</code> on the <code class="literal">ProceedingJoinPoint</code> causes the underlying method to
execute. The <code class="literal">proceed</code> method may also be called passing in an <code class="literal">Object[]</code> - the values
in the array will be used as the arguments to the method execution when it proceeds.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>The behavior of proceed when called with an Object[] is a little different than the
behavior of proceed for around advice compiled by the AspectJ compiler. For around
advice written using the traditional AspectJ language, the number of arguments passed to
proceed must match the number of arguments passed to the around advice (not the number
of arguments taken by the underlying join point), and the value passed to proceed in a
given argument position supplants the original value at the join point for the entity
the value was bound to (Don’t worry if this doesn’t make sense right now!). The approach
taken by Spring is simpler and a better match to its proxy-based, execution only
semantics. You only need to be aware of this difference if you are compiling @AspectJ
aspects written for Spring and using proceed with arguments with the AspectJ compiler
and weaver. There is a way to write such aspects that is 100% compatible across both
Spring AOP and AspectJ, and this is discussed in the following section on advice
parameters.</p>
</td></tr></tbody></table></div>
<pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Around;
<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AroundExample {

    <em><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService()")</span></em>
    <span class="hl-keyword">public</span> Object doBasicProfiling(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
        <span class="hl-comment">// start stopwatch</span>
        Object retVal = pjp.proceed();
        <span class="hl-comment">// stop stopwatch</span>
        <span class="hl-keyword">return</span> retVal;
    }

}</pre>
<p>The value returned by the around advice will be the return value seen by the caller of
the method. A simple caching aspect for example could return a value from a cache if it
has one, and invoke proceed() if it does not. Note that proceed may be invoked once,
many times, or not at all within the body of the around advice, all of these are quite
legal.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-params" href="#aop-ataspectj-advice-params"></a>Advice parameters</h4></div></div></div>
<p>Spring offers fully typed advice - meaning that you declare the parameters you need
in the advice signature (as we saw for the returning and throwing examples above) rather
than work with <code class="literal">Object[]</code> arrays all the time. We’ll see how to make argument and other
contextual values available to the advice body in a moment. First let’s take a look at
how to write generic advice that can find out about the method the advice is currently
advising.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-the-joinpoint" href="#aop-ataspectj-advice-params-the-joinpoint"></a>Access to the current JoinPoint</h5></div></div></div>
<p>Any advice method may declare as its first parameter, a parameter of type
<code class="literal">org.aspectj.lang.JoinPoint</code> (please note that around advice is <span class="emphasis"><em>required</em></span> to declare
a first parameter of type <code class="literal">ProceedingJoinPoint</code>, which is a subclass of <code class="literal">JoinPoint</code>. The
<code class="literal">JoinPoint</code> interface provides a number of useful methods such as <code class="literal">getArgs()</code> (returns
the method arguments), <code class="literal">getThis()</code> (returns the proxy object), <code class="literal">getTarget()</code> (returns
the target object), <code class="literal">getSignature()</code> (returns a description of the method that is being
advised) and <code class="literal">toString()</code> (prints a useful description of the method being advised).
Please do consult the javadocs for full details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-passing" href="#aop-ataspectj-advice-params-passing"></a>Passing parameters to advice</h5></div></div></div>
<p>We’ve already seen how to bind the returned value or exception value (using after
returning and after throwing advice). To make argument values available to the advice
body, you can use the binding form of <code class="literal">args</code>. If a parameter name is used in place of a
type name in an args expression, then the value of the corresponding argument will be
passed as the parameter value when the advice is invoked. An example should make this
clearer. Suppose you want to advise the execution of dao operations that take an Account
object as the first parameter, and you need access to the account in the advice body.
You could write the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validateAccount(Account account) {
    <span class="hl-comment">// ...</span>
}</pre>
<p>The <code class="literal">args(account,..)</code> part of the pointcut expression serves two purposes: firstly, it
restricts matching to only those method executions where the method takes at least one
parameter, and the argument passed to that parameter is an instance of <code class="literal">Account</code>;
secondly, it makes the actual <code class="literal">Account</code> object available to the advice via the <code class="literal">account</code>
parameter.</p>
<p>Another way of writing this is to declare a pointcut that "provides" the <code class="literal">Account</code>
object value when it matches a join point, and then just refer to the named pointcut
from the advice. This would look as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")</span></em>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> accountDataAccessOperation(Account account) {}

<em><span class="hl-annotation" style="color: gray">@Before("accountDataAccessOperation(account)")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validateAccount(Account account) {
    <span class="hl-comment">// ...</span>
}</pre>
<p>The interested reader is once more referred to the AspectJ programming guide for more
details.</p>
<p>The proxy object ( <code class="literal">this</code>), target object ( <code class="literal">target</code>), and annotations ( <code class="literal">@within,
@target, @annotation, @args</code>) can all be bound in a similar fashion. The following
example shows how you could match the execution of methods annotated with an
<code class="literal">@Auditable</code> annotation, and extract the audit code.</p>
<p>First the definition of the <code class="literal">@Auditable</code> annotation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@Target(ElementType.METHOD)</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> Auditable {
    AuditCode value();
}</pre>
<p>And then the advice that matches the execution of <code class="literal">@Auditable</code> methods:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(Auditable auditable) {
    AuditCode code = auditable.value();
    <span class="hl-comment">// ...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-generics" href="#aop-ataspectj-advice-params-generics"></a>Advice parameters and generics</h5></div></div></div>
<p>Spring AOP can handle generics used in class declarations and method parameters. Suppose
you have a generic type like this:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Sample&lt;T&gt; {
    <span class="hl-keyword">void</span> sampleGenericMethod(T param);
    <span class="hl-keyword">void</span> sampleGenericCollectionMethod(Collection&lt;T&gt; param);
}</pre>
<p>You can restrict interception of method types to certain parameter types by simply
typing the advice parameter to the parameter type you want to intercept the method for:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeSampleMethod(MyType param) {
    <span class="hl-comment">// Advice implementation</span>
}</pre>
<p>That this works is pretty obvious as we already discussed above. However, it’s worth
pointing out that this won’t work for generic collections. So you cannot define a
pointcut like this:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeSampleMethod(Collection&lt;MyType&gt; param) {
    <span class="hl-comment">// Advice implementation</span>
}</pre>
<p>To make this work we would have to inspect every element of the collection, which is not
reasonable as we also cannot decide how to treat <code class="literal">null</code> values in general. To achieve
something similar to this you have to type the parameter to <code class="literal">Collection&lt;?&gt;</code> and manually
check the type of the elements.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-names" href="#aop-ataspectj-advice-params-names"></a>Determining argument names</h5></div></div></div>
<p>The parameter binding in advice invocations relies on matching names used in pointcut
expressions to declared parameter names in (advice and pointcut) method signatures.
Parameter names are <span class="emphasis"><em>not</em></span> available through Java reflection, so Spring AOP uses the
following strategies to determine parameter names:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If the parameter names have been specified by the user explicitly, then the specified
parameter names are used: both the advice and the pointcut annotations have
an optional "argNames" attribute which can be used to specify the argument names of
the annotated method - these argument names <span class="emphasis"><em>are</em></span> available at runtime. For example:
</li></ul></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    <span class="hl-comment">// ... use code and bean</span>
}</pre>
<p>If the first parameter is of the <code class="literal">JoinPoint</code>, <code class="literal">ProceedingJoinPoint</code>, or
<code class="literal">JoinPoint.StaticPart</code> type, you may leave out the name of the parameter from the value
of the "argNames" attribute. For example, if you modify the preceding advice to receive
the join point object, the "argNames" attribute need not include it:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(JoinPoint jp, Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    <span class="hl-comment">// ... use code, bean, and jp</span>
}</pre>
<p>The special treatment given to the first parameter of the <code class="literal">JoinPoint</code>,
<code class="literal">ProceedingJoinPoint</code>, and <code class="literal">JoinPoint.StaticPart</code> types is particularly convenient for
advice that do not collect any other join point context. In such situations, you may
simply omit the "argNames" attribute. For example, the following advice need not declare
the "argNames" attribute:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(JoinPoint jp) {
    <span class="hl-comment">// ... use jp</span>
}</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Using the <code class="literal">'argNames'</code> attribute is a little clumsy, so if the <code class="literal">'argNames'</code> attribute
has not been specified, then Spring AOP will look at the debug information for the
class and try to determine the parameter names from the local variable table. This
information will be present as long as the classes have been compiled with debug
information ( <code class="literal">'-g:vars'</code> at a minimum). The consequences of compiling with this flag
on are: (1) your code will be slightly easier to understand (reverse engineer), (2)
the class file sizes will be very slightly bigger (typically inconsequential), (3) the
optimization to remove unused local variables will not be applied by your compiler. In
other words, you should encounter no difficulties building with this flag on.
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the
debug information then there is no need to add the argNames attribute as the compiler
will retain the needed information.</p>
</td></tr></tbody></table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If the code has been compiled without the necessary debug information, then Spring AOP
will attempt to deduce the pairing of binding variables to parameters (for example, if
only one variable is bound in the pointcut expression, and the advice method only
takes one parameter, the pairing is obvious!). If the binding of variables is
ambiguous given the available information, then an <code class="literal">AmbiguousBindingException</code> will be
thrown.
</li><li class="listitem">
If all of the above strategies fail then an <code class="literal">IllegalArgumentException</code> will be thrown.
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-proceeding-with-the-call" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>Proceeding with arguments</h5></div></div></div>
<p>We remarked earlier that we would describe how to write a proceed call <span class="emphasis"><em>with
arguments</em></span> that works consistently across Spring AOP and AspectJ. The solution is
simply to ensure that the advice signature binds each of the method parameters in order.
For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")</span></em>
<span class="hl-keyword">public</span> Object preProcessQueryPattern(ProceedingJoinPoint pjp,
        String accountHolderNamePattern) <span class="hl-keyword">throws</span> Throwable {
    String newPattern = preProcess(accountHolderNamePattern);
    <span class="hl-keyword">return</span> pjp.proceed(<span class="hl-keyword">new</span> Object[] {newPattern});
}</pre>
<p>In many cases you will be doing this binding anyway (as in the example above).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-ordering" href="#aop-ataspectj-advice-ordering"></a>Advice ordering</h4></div></div></div>
<p>What happens when multiple pieces of advice all want to run at the same join point?
Spring AOP follows the same precedence rules as AspectJ to determine the order of advice
execution. The highest precedence advice runs first "on the way in" (so given two pieces
of before advice, the one with highest precedence runs first). "On the way out" from a
join point, the highest precedence advice runs last (so given two pieces of after
advice, the one with the highest precedence will run second).</p>
<p>When two pieces of advice defined in <span class="emphasis"><em>different</em></span> aspects both need to run at the same
join point, unless you specify otherwise the order of execution is undefined. You can
control the order of execution by specifying precedence. This is done in the normal
Spring way by either implementing the <code class="literal">org.springframework.core.Ordered</code> interface in
the aspect class or annotating it with the <code class="literal">Order</code> annotation. Given two aspects, the
aspect returning the lower value from <code class="literal">Ordered.getValue()</code> (or the annotation value) has
the higher precedence.</p>
<p>When two pieces of advice defined in <span class="emphasis"><em>the same</em></span> aspect both need to run at the same
join point, the ordering is undefined (since there is no way to retrieve the declaration
order via reflection for javac-compiled classes). Consider collapsing such advice
methods into one advice method per join point in each aspect class, or refactor the
pieces of advice into separate aspect classes - which can be ordered at the aspect level.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introductions" href="#aop-introductions"></a>11.2.5 Introductions</h3></div></div></div>
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
<p>An introduction is made using the <code class="literal">@DeclareParents</code> annotation. This annotation is used
to declare that matching types have a new parent (hence the name). For example, given an
interface <code class="literal">UsageTracked</code>, and an implementation of that interface <code class="literal">DefaultUsageTracked</code>,
the following aspect declares that all implementors of service interfaces also implement
the <code class="literal">UsageTracked</code> interface. (In order to expose statistics via JMX for example.)</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UsageTracking {

    <em><span class="hl-annotation" style="color: gray">@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> UsageTracked mixin;

    <em><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordUsage(UsageTracked usageTracked) {
        usageTracked.incrementUseCount();
    }

}</pre>
<p>The interface to be implemented is determined by the type of the annotated field. The
<code class="literal">value</code> attribute of the <code class="literal">@DeclareParents</code> annotation is an AspectJ type pattern :- any
bean of a matching type will implement the UsageTracked interface. Note that in the
before advice of the above example, service beans can be directly used as
implementations of the <code class="literal">UsageTracked</code> interface. If accessing a bean programmatically
you would write the following:</p>
<pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hl-string">"myService"</span>);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-instantiation-models" href="#aop-instantiation-models"></a>11.2.6 Aspect instantiation models</h3></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>(This is an advanced topic, so if you are just starting out with AOP you can safely skip
it until later.)</p>
</td></tr></tbody></table></div>
<p>By default there will be a single instance of each aspect within the application
context. AspectJ calls this the singleton instantiation model. It is possible to define
aspects with alternate lifecycles :- Spring supports AspectJ’s <code class="literal">perthis</code> and <code class="literal">pertarget</code>
instantiation models ( <code class="literal">percflow, percflowbelow,</code> and <code class="literal">pertypewithin</code> are not currently
supported).</p>
<p>A "perthis" aspect is declared by specifying a <code class="literal">perthis</code> clause in the <code class="literal">@Aspect</code>
annotation. Let’s look at an example, and then we’ll explain how it works.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAspect {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> someState;

    <em><span class="hl-annotation" style="color: gray">@Before(com.xyz.myapp.SystemArchitecture.businessService())</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordServiceUsage() {
        <span class="hl-comment">// ...</span>
    }

}</pre>
<p>The effect of the <code class="literal">'perthis'</code> clause is that one aspect instance will be created for
each unique service object executing a business service (each unique object bound to
'this' at join points matched by the pointcut expression). The aspect instance is
created the first time that a method is invoked on the service object. The aspect goes
out of scope when the service object goes out of scope. Before the aspect instance is
created, none of the advice within it executes. As soon as the aspect instance has been
created, the advice declared within it will execute at matched join points, but only
when the service object is the one this aspect is associated with. See the AspectJ
programming guide for more information on per-clauses.</p>
<p>The <code class="literal">'pertarget'</code> instantiation model works in exactly the same way as perthis, but
creates one aspect instance for each unique target object at matched join points.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-example" href="#aop-ataspectj-example"></a>11.2.7 Example</h3></div></div></div>
<p>Now that you have seen how all the constituent parts work, let’s put them together to do
something useful!</p>
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, deadlock loser). If the operation is retried, it is quite likely to succeed
next time round. For business services where it is appropriate to retry in such
conditions (idempotent operations that don’t need to go back to the user for conflict
resolution), we’d like to transparently retry the operation to avoid the client seeing a
<code class="literal">PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer, and hence is ideal for implementing via an
aspect.</p>
<p>Because we want to retry the operation, we will need to use around advice so that we can
call proceed multiple times. Here’s how the basic aspect implementation looks:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConcurrentOperationExecutor <span class="hl-keyword">implements</span> Ordered {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> DEFAULT_MAX_RETRIES = <span class="hl-number">2</span>;

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> order = <span class="hl-number">1</span>;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMaxRetries(<span class="hl-keyword">int</span> maxRetries) {
        <span class="hl-keyword">this</span>.maxRetries = maxRetries;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getOrder() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.order;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrder(<span class="hl-keyword">int</span> order) {
        <span class="hl-keyword">this</span>.order = order;
    }

    <em><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService()")</span></em>
    <span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
        <span class="hl-keyword">int</span> numAttempts = <span class="hl-number">0</span>;
        PessimisticLockingFailureException lockFailureException;
        <span class="hl-keyword">do</span> {
            numAttempts++;
            <span class="hl-keyword">try</span> {
                <span class="hl-keyword">return</span> pjp.proceed();
            }
            <span class="hl-keyword">catch</span>(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } <span class="hl-keyword">while</span>(numAttempts &lt;= <span class="hl-keyword">this</span>.maxRetries);
        <span class="hl-keyword">throw</span> lockFailureException;
    }

}</pre>
<p>Note that the aspect implements the <code class="literal">Ordered</code> interface so we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code class="literal">maxRetries</code> and <code class="literal">order</code> properties will both be configured by Spring. The
main action happens in the <code class="literal">doConcurrentOperation</code> around advice. Notice that for the
moment we’re applying the retry logic to all <code class="literal">businessService()s</code>. We try to proceed,
and if we fail with an <code class="literal">PessimisticLockingFailureException</code> we simply try again unless
we have exhausted all of our retry attempts.</p>
<p>The corresponding Spring configuration is:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationExecutor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxRetries"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>To refine the aspect so that it only retries idempotent operations, we might define an
<code class="literal">Idempotent</code> annotation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> Idempotent {
    <span class="hl-comment">// marker annotation</span>
}</pre>
<p>and use the annotation to annotate the implementation of service operations. The change
to the aspect to only retry idempotent operations simply involves refining the pointcut
expression so that only <code class="literal">@Idempotent</code> operations match:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " +
        "@annotation(com.xyz.myapp.service.Idempotent)")</span></em>
<span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
    ...
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-schema" href="#aop-schema"></a>11.3 Schema-based AOP support</h2></div></div></div>
<p>If you prefer an XML-based format, then Spring also offers support for defining aspects
using the new "aop" namespace tags. The exact same pointcut expressions and advice kinds
are supported as when using the @AspectJ style, hence in this section we will focus on
the new <span class="emphasis"><em>syntax</em></span> and refer the reader to the discussion in the previous section
(<a class="xref" href="aop.html#aop-ataspectj" title="11.2 @AspectJ support">Section 11.2, “@AspectJ support”</a>) for an understanding of writing pointcut expressions and the binding
of advice parameters.</p>
<p>To use the aop namespace tags described in this section, you need to import the
<code class="literal">spring-aop</code> schema as described in <a class="xref" href="xsd-configuration.html" title="41. XML Schema-based configuration">Chapter 41, <i>XML Schema-based configuration</i></a>. See <a class="xref" href="xsd-configuration.html#xsd-config-body-schemas-aop" title="41.2.7 the aop schema">Section 41.2.7, “the aop schema”</a>
for how to import the tags in the <code class="literal">aop</code> namespace.</p>
<p>Within your Spring configurations, all aspect and advisor elements must be placed within
an <code class="literal">&lt;aop:config&gt;</code> element (you can have more than one <code class="literal">&lt;aop:config&gt;</code> element in an
application context configuration). An <code class="literal">&lt;aop:config&gt;</code> element can contain pointcut,
advisor, and aspect elements (note these must be declared in that order).</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Warning]" data-savepage-src="images/warning.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAACslBMVEX///+/zDGkrzU5ai4zYio1ZSs4aC08bTA+bzFAcjNCdDRDdzYxYCgvXSfL01ouWyYeSRksWSQgShooVCEwXidFeDcYQRMfShohTBshTR0lUR8qVyMtWiVGezhMfDpbhUUXQRMYQhMaRBUcRhciTx4hUB8hUSAjUiEmUR8kVCMoVSEpViIoWSYsXikwXygyYCk2ZSw3Zy07bDA9bjFIfDlYeEpUfEBaekxliVBskFaMpnjU2nwWQBIZQxQZQxUdQhcbRRYfRBkgRRohRhseSBkiRxsiSBwkSh4lSx8mTB8hTx4jUB8kUB4iUSAjUSAkUiElUiErTyMkUyInUyEqUSUlVCMlVSMnVSIsUiYmViQpVSIoViInVyQrWCQwWCktWyU2ViwtXCcsXSgvXCY0WisuXigvYSsyYSowYis1YCo1YS0zZSw8YDI0Zi08YjI3aC48ZTI3aS5FYDlBYzY6azA6bDBEaDg7bjFIZT5EaTU8bjFJZj87cDM8cDM8cTQ9cTREczVFczVBdjZDdjZCdzZCejlFejhGezpJejhKeTxGfDpKezlJfTlIfjpJfjpKfjpJfzpKfj1ac01PfzxQfzxSfUJYekZQgj5TgT9WgEZYgkdXhkNZhElhflRkgFdnflxciEppf15hiFBfik1nhVpkjE5kjFJrh11ojlZqjlRziWVskVZukVhxj117kG12l192l2B3lWh4lWd4l2R+knJ6mmOElniEmnaGmXmCnm6FonGHonSHo3OMo3qPoIKOooGOpX6QpoCSqYCVq4GVq4KdqZKcq5CstUehrZaitZKktZWmuJeuuaWvvaK2v6y5wrC8x7DAx7e/ybPBybfDy7zP123H0LzJz8HM08TN08bY3YnP1sbb4JTW3M7Y3NPc4dXd4dbk6ODt7+ry8/D3+Pb8/PvcsaW3AAABuklEQVR42mNggIJLBzfNmrnxwIWnDCjg9OLp63dZWe3ZOnvBSSTh+yt6Vx8+xHScadXeIxsmLLsLE789sWfp7s2Md64yMU1au9Oyr+saRPxhu0n/mpUWjLcYGZmKpllYTjFpfQCWWNQmO1le3oyRDyiRUGkmP0NWdg5I/GyTqGiHnFwjWCIws0GuW1S05RRQYmozNwgYgyU8k43BvE4Ghht1XGBgBJbwiDcC8+ovM+yv4QQDZrCEuyAzmFe7nWF5FQcYGIIl3KQNwbzyJQzmJexgYACWcI0yAPNKzRlM85nBgIURCJicglnAvEJThnnZbGCgrwGUcBTS0Afzcucy7EhjBQMRKXEBAQFxKREwL2MdwxXddBYQ0NOyZmSyl9DSA/N0zzEwFCTxgICINcgOZ2kRECc1C+jzYzqJvEAgA7Kc0UVKBsTR2QcKrLJIGX5+fm0hoLitnZA2kB2TBw7de5qhsYKCwgKKYmJiigLCgoJhmjchEXI+SD1cWlhCScFGQUlCONpf/QwsCq8Xq/kG+AgpOyiLq/ip5VxEivVtKareKpKSkl6qcVueoCSTxycWVkeEVMw/+ggqAABQ8XNwHY+9TQAAAABJRU5ErkJggg=="></td><th align="left">Warning</th></tr><tr><td valign="top" align="left">
<p>The <code class="literal">&lt;aop:config&gt;</code> style of configuration makes heavy use of Spring’s
<a class="link" href="aop-api.html#aop-autoproxy" title="12.9 Using the &quot;auto-proxy&quot; facility">auto-proxying</a> mechanism. This can cause issues (such as advice not
being woven) if you are already using explicit auto-proxying via the use of
<code class="literal">BeanNameAutoProxyCreator</code> or suchlike. The recommended usage pattern is to use either
just the <code class="literal">&lt;aop:config&gt;</code> style, or just the <code class="literal">AutoProxyCreator</code> style.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-declaring-an-aspect" href="#aop-schema-declaring-an-aspect"></a>11.3.1 Declaring an aspect</h3></div></div></div>
<p>Using the schema support, an aspect is simply a regular Java object defined as a bean in
your Spring application context. The state and behavior is captured in the fields and
methods of the object, and the pointcut and advice information is captured in the XML.</p>
<p>An aspect is declared using the &lt;aop:aspect&gt; element, and the backing bean is referenced
using the <code class="literal">ref</code> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
    <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>
        ...
    <span class="hl-tag">&lt;/aop:aspect&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"aBean"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The bean backing the aspect (" `aBean`" in this case) can of course be configured and
dependency injected just like any other Spring bean.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-pointcuts" href="#aop-schema-pointcuts"></a>11.3.2 Declaring a pointcut</h3></div></div></div>
<p>A named pointcut can be declared inside an &lt;aop:config&gt; element, enabling the pointcut
definition to be shared across several aspects and advisors.</p>
<p>A pointcut representing the execution of any business service in the service layer could
be defined as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>Note that the pointcut expression itself is using the same AspectJ pointcut expression
language as described in <a class="xref" href="aop.html#aop-ataspectj" title="11.2 @AspectJ support">Section 11.2, “@AspectJ support”</a>. If you are using the schema based
declaration style, you can refer to named pointcuts defined in types
(@Aspects) within the pointcut expression. Another way of defining the above pointcut
would be:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"com.xyz.myapp.SystemArchitecture.businessService()"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>Assuming you have a <code class="literal">SystemArchitecture</code> aspect as described in <a class="xref" href="aop.html#aop-common-pointcuts" title="Sharing common pointcut definitions">the section called “Sharing common pointcut definitions”</a>.</p>
<p>Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
            <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

        ...

    <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>Much the same way in an @AspectJ aspect, pointcuts declared using the schema based
definition style may collect join point context. For example, the following pointcut
collects the 'this' object as the join point context and passes it to advice:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
            <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"</span><span class="hl-tag">/&gt;</span>

        <span class="hl-tag">&lt;aop:before</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"monitor"</span><span class="hl-tag">/&gt;</span>

        ...

    <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>The advice must be declared to receive the collected join point context by including
parameters of the matching names:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> monitor(Object service) {
    ...
}</pre>
<p>When combining pointcut sub-expressions, '&amp;&amp;' is awkward within an XML document, and so
the keywords 'and', 'or' and 'not' can be used in place of '&amp;&amp;', '||' and '!'
respectively. For example, the previous pointcut may be better written as:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
            <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) **and** this(service)"</span><span class="hl-tag">/&gt;</span>

        <span class="hl-tag">&lt;aop:before</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"monitor"</span><span class="hl-tag">/&gt;</span>

        ...
    <span class="hl-tag">&lt;/aop:aspect&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>Note that pointcuts defined in this way are referred to by their XML id and cannot be
used as named pointcuts to form composite pointcuts. The named pointcut support in the
schema based definition style is thus more limited than that offered by the @AspectJ
style.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advice" href="#aop-schema-advice"></a>11.3.3 Declaring advice</h3></div></div></div>
<p>The same five advice kinds are supported as for the @AspectJ style, and they have
exactly the same semantics.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-before" href="#aop-schema-advice-before"></a>Before advice</h4></div></div></div>
<p>Before advice runs before a matched method execution. It is declared inside an
<code class="literal">&lt;aop:aspect&gt;</code> using the &lt;aop:before&gt; element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"beforeExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:before</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>Here <code class="literal">dataAccessOperation</code> is the id of a pointcut defined at the top ( <code class="literal">&lt;aop:config&gt;</code>)
level. To define the pointcut inline instead, replace the <code class="literal">pointcut-ref</code> attribute with
a <code class="literal">pointcut</code> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"beforeExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:before</span>
        <span class="hl-attribute">pointcut</span>=<span class="hl-value">"execution(* com.xyz.myapp.dao.*.*(..))"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>As we noted in the discussion of the @AspectJ style, using named pointcuts can
significantly improve the readability of your code.</p>
<p>The method attribute identifies a method ( <code class="literal">doAccessCheck</code>) that provides the body of
the advice. This method must be defined for the bean referenced by the aspect element
containing the advice. Before a data access operation is executed (a method execution
join point matched by the pointcut expression), the "doAccessCheck" method on the aspect
bean will be invoked.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-returning" href="#aop-schema-advice-after-returning"></a>After returning advice</h4></div></div></div>
<p>After returning advice runs when a matched method execution completes normally. It is
declared inside an <code class="literal">&lt;aop:aspect&gt;</code> in the same way as before advice. For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterReturningExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-returning</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>Just as in the @AspectJ style, it is possible to get hold of the return value within the
advice body. Use the returning attribute to specify the name of the parameter to which
the return value should be passed:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterReturningExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-returning</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">returning</span>=<span class="hl-value">"retVal"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>The doAccessCheck method must declare a parameter named <code class="literal">retVal</code>. The type of this
parameter constrains matching in the same way as described for @AfterReturning. For
example, the method signature may be declared as:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck(Object retVal) {...</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-throwing" href="#aop-schema-advice-after-throwing"></a>After throwing advice</h4></div></div></div>
<p>After throwing advice executes when a matched method execution exits by throwing an
exception. It is declared inside an <code class="literal">&lt;aop:aspect&gt;</code> using the after-throwing element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterThrowingExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-throwing</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doRecoveryActions"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>Just as in the @AspectJ style, it is possible to get hold of the thrown exception within
the advice body. Use the throwing attribute to specify the name of the parameter to
which the exception should be passed:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterThrowingExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-throwing</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">throwing</span>=<span class="hl-value">"dataAccessEx"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doRecoveryActions"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>The doRecoveryActions method must declare a parameter named <code class="literal">dataAccessEx</code>. The type of
this parameter constrains matching in the same way as described for @AfterThrowing. For
example, the method signature may be declared as:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions(DataAccessException dataAccessEx) {...</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-finally" href="#aop-schema-advice-after-finally"></a>After (finally) advice</h4></div></div></div>
<p>After (finally) advice runs however a matched method execution exits. It is declared
using the <code class="literal">after</code> element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterFinallyExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doReleaseLock"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-around" href="#aop-schema-advice-around"></a>Around advice</h4></div></div></div>
<p>The final kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method executes,
and to determine when, how, and even if, the method actually gets to execute at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer for example). Always
use the least powerful form of advice that meets your requirements; don’t use around
advice if simple before advice would do.</p>
<p>Around advice is declared using the <code class="literal">aop:around</code> element. The first parameter of the
advice method must be of type <code class="literal">ProceedingJoinPoint</code>. Within the body of the advice,
calling <code class="literal">proceed()</code> on the <code class="literal">ProceedingJoinPoint</code> causes the underlying method to
execute. The <code class="literal">proceed</code> method may also be calling passing in an <code class="literal">Object[]</code> - the values
in the array will be used as the arguments to the method execution when it proceeds. See
<a class="xref" href="aop.html#aop-ataspectj-around-advice" title="Around advice">the section called “Around advice”</a> for notes on calling proceed with an <code class="literal">Object[]</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"aroundExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:around</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">method</span>=<span class="hl-value">"doBasicProfiling"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>The implementation of the <code class="literal">doBasicProfiling</code> advice would be exactly the same as in the
@AspectJ example (minus the annotation of course):</p>
<pre class="programlisting"><span class="hl-keyword">public</span> Object doBasicProfiling(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
    <span class="hl-comment">// start stopwatch</span>
    Object retVal = pjp.proceed();
    <span class="hl-comment">// stop stopwatch</span>
    <span class="hl-keyword">return</span> retVal;
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-params" href="#aop-schema-params"></a>Advice parameters</h4></div></div></div>
<p>The schema based declaration style supports fully typed advice in the same way as
described for the @AspectJ support - by matching pointcut parameters by name against
advice method parameters. See <a class="xref" href="aop.html#aop-ataspectj-advice-params" title="Advice parameters">the section called “Advice parameters”</a> for details. If you wish
to explicitly specify argument names for the advice methods (not relying on the
detection strategies previously described) then this is done using the <code class="literal">arg-names</code>
attribute of the advice element, which is treated in the same manner to the "argNames"
attribute in an advice annotation as described in <a class="xref" href="aop.html#aop-ataspectj-advice-params-names" title="Determining argument names">the section called “Determining argument names”</a>.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:before</span>
    <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"</span>
    <span class="hl-attribute">method</span>=<span class="hl-value">"audit"</span>
    <span class="hl-attribute">arg-names</span>=<span class="hl-value">"auditable"</span><span class="hl-tag">/&gt;</span></pre>
<p>The <code class="literal">arg-names</code> attribute accepts a comma-delimited list of parameter names.</p>
<p>Find below a slightly more involved example of the XSD-based approach that illustrates
some around advice used in conjunction with a number of strongly typed parameters.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> x.y.service;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FooService {

    Foo getFoo(String fooName, <span class="hl-keyword">int</span> age);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultFooService <span class="hl-keyword">implements</span> FooService {

    <span class="hl-keyword">public</span> Foo getFoo(String name, <span class="hl-keyword">int</span> age) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Foo(name, age);
    }
}</pre>
<p>Next up is the aspect. Notice the fact that the <code class="literal">profile(..)</code> method accepts a number of
strongly-typed parameters, the first of which happens to be the join point used to
proceed with the method call: the presence of this parameter is an indication that the
<code class="literal">profile(..)</code> is to be used as <code class="literal">around</code> advice:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> x.y;

<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hl-keyword">import</span> org.springframework.util.StopWatch;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleProfiler {

    <span class="hl-keyword">public</span> Object profile(ProceedingJoinPoint call, String name, <span class="hl-keyword">int</span> age) <span class="hl-keyword">throws</span> Throwable {
        StopWatch clock = <span class="hl-keyword">new</span> StopWatch(<span class="hl-string">"Profiling for '"</span> + name + <span class="hl-string">"' and '"</span> + age + <span class="hl-string">"'"</span>);
        <span class="hl-keyword">try</span> {
            clock.start(call.toShortString());
            <span class="hl-keyword">return</span> call.proceed();
        } <span class="hl-keyword">finally</span> {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
    }
}</pre>
<p>Finally, here is the XML configuration that is required to effect the execution of the
above advice for a particular join point:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fooService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"x.y.service.DefaultFooService"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- this is the actual advice itself --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"profiler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"x.y.SimpleProfiler"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"profiler"</span><span class="hl-tag">&gt;</span>

            <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"theExecutionOfSomeFooServiceMethod"</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* x.y.service.FooService.getFoo(String,int))
                and args(name, age)"</span><span class="hl-tag">/&gt;</span>

            <span class="hl-tag">&lt;aop:around</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"theExecutionOfSomeFooServiceMethod"</span>
                <span class="hl-attribute">method</span>=<span class="hl-value">"profile"</span><span class="hl-tag">/&gt;</span>

        <span class="hl-tag">&lt;/aop:aspect&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>If we had the following driver script, we would get output something like this on
standard output:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.beans.factory.BeanFactory;
<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class="hl-keyword">import</span> x.y.service.FooService;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Boot {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(<span class="hl-keyword">final</span> String[] args) <span class="hl-keyword">throws</span> Exception {
        BeanFactory ctx = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"x/y/plain.xml"</span>);
        FooService foo = (FooService) ctx.getBean(<span class="hl-string">"fooService"</span>);
        foo.getFoo(<span class="hl-string">"Pengo"</span>, <span class="hl-number">12</span>);
    }
}</pre>
<pre class="literallayout">StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ordering" href="#aop-ordering"></a>Advice ordering</h4></div></div></div>
<p>When multiple advice needs to execute at the same join point (executing method) the
ordering rules are as described in <a class="xref" href="aop.html#aop-ataspectj-advice-ordering" title="Advice ordering">the section called “Advice ordering”</a>. The precedence
between aspects is determined by either adding the <code class="literal">Order</code> annotation to the bean
backing the aspect or by having the bean implement the <code class="literal">Ordered</code> interface.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-introductions" href="#aop-schema-introductions"></a>11.3.4 Introductions</h3></div></div></div>
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
<p>An introduction is made using the <code class="literal">aop:declare-parents</code> element inside an <code class="literal">aop:aspect</code>
This element is used to declare that matching types have a new parent (hence the name).
For example, given an interface <code class="literal">UsageTracked</code>, and an implementation of that interface
<code class="literal">DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code class="literal">UsageTracked</code> interface. (In order to expose statistics
via JMX for example.)</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"usageTrackerAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"usageTracking"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:declare-parents</span>
        <span class="hl-attribute">types-matching</span>=<span class="hl-value">"com.xzy.myapp.service.*+"</span>
        <span class="hl-attribute">implement-interface</span>=<span class="hl-value">"com.xyz.myapp.service.tracking.UsageTracked"</span>
        <span class="hl-attribute">default-impl</span>=<span class="hl-value">"com.xyz.myapp.service.tracking.DefaultUsageTracked"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;aop:before</span>
        <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.myapp.SystemArchitecture.businessService()
            and this(usageTracked)"</span>
            <span class="hl-attribute">method</span>=<span class="hl-value">"recordUsage"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
<p>The class backing the <code class="literal">usageTracking</code> bean would contain the method:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</pre>
<p>The interface to be implemented is determined by <code class="literal">implement-interface</code> attribute. The
value of the <code class="literal">types-matching</code> attribute is an AspectJ type pattern :- any bean of a
matching type will implement the <code class="literal">UsageTracked</code> interface. Note that in the before
advice of the above example, service beans can be directly used as implementations of
the <code class="literal">UsageTracked</code> interface. If accessing a bean programmatically you would write the
following:</p>
<pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hl-string">"myService"</span>);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-instatiation-models" href="#aop-schema-instatiation-models"></a>11.3.5 Aspect instantiation models</h3></div></div></div>
<p>The only supported instantiation model for schema-defined aspects is the singleton
model. Other instantiation models may be supported in future releases.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advisors" href="#aop-schema-advisors"></a>11.3.6 Advisors</h3></div></div></div>
<p>The concept of "advisors" is brought forward from the AOP support defined in Spring 1.2
and does not have a direct equivalent in AspectJ. An advisor is like a small
self-contained aspect that has a single piece of advice. The advice itself is
represented by a bean, and must implement one of the advice interfaces described in
<a class="xref" href="aop-api.html#aop-api-advice-types" title="12.3.2 Advice types in Spring">Section 12.3.2, “Advice types in Spring”</a>. Advisors can take advantage of AspectJ pointcut expressions
though.</p>
<p>Spring supports the advisor concept with the <code class="literal">&lt;aop:advisor&gt;</code> element. You will most
commonly see it used in conjunction with transactional advice, which also has its own
namespace support in Spring. Here’s how it looks:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;aop:advisor</span>
        <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;tx:attributes&gt;</span>
        <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>
<p>As well as the <code class="literal">pointcut-ref</code> attribute used in the above example, you can also use the
<code class="literal">pointcut</code> attribute to define a pointcut expression inline.</p>
<p>To define the precedence of an advisor so that the advice can participate in ordering,
use the <code class="literal">order</code> attribute to define the <code class="literal">Ordered</code> value of the advisor.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-example" href="#aop-schema-example"></a>11.3.7 Example</h3></div></div></div>
<p>Let’s see how the concurrent locking failure retry example from
<a class="xref" href="aop.html#aop-ataspectj-example" title="11.2.7 Example">Section 11.2.7, “Example”</a> looks when rewritten using the schema support.</p>
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, deadlock loser). If the operation is retried, it is quite likely it will
succeed next time round. For business services where it is appropriate to retry in such
conditions (idempotent operations that don’t need to go back to the user for conflict
resolution), we’d like to transparently retry the operation to avoid the client seeing a
<code class="literal">PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer, and hence is ideal for implementing via an
aspect.</p>
<p>Because we want to retry the operation, we’ll need to use around advice so that we can
call proceed multiple times. Here’s how the basic aspect implementation looks (it’s just
a regular Java class using the schema support):</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConcurrentOperationExecutor <span class="hl-keyword">implements</span> Ordered {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> DEFAULT_MAX_RETRIES = <span class="hl-number">2</span>;

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> order = <span class="hl-number">1</span>;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMaxRetries(<span class="hl-keyword">int</span> maxRetries) {
        <span class="hl-keyword">this</span>.maxRetries = maxRetries;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getOrder() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.order;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrder(<span class="hl-keyword">int</span> order) {
        <span class="hl-keyword">this</span>.order = order;
    }

    <span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
        <span class="hl-keyword">int</span> numAttempts = <span class="hl-number">0</span>;
        PessimisticLockingFailureException lockFailureException;
        <span class="hl-keyword">do</span> {
            numAttempts++;
            <span class="hl-keyword">try</span> {
                <span class="hl-keyword">return</span> pjp.proceed();
            }
            <span class="hl-keyword">catch</span>(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } <span class="hl-keyword">while</span>(numAttempts &lt;= <span class="hl-keyword">this</span>.maxRetries);
        <span class="hl-keyword">throw</span> lockFailureException;
    }

}</pre>
<p>Note that the aspect implements the <code class="literal">Ordered</code> interface so we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code class="literal">maxRetries</code> and <code class="literal">order</code> properties will both be configured by Spring. The
main action happens in the <code class="literal">doConcurrentOperation</code> around advice method. We try to
proceed, and if we fail with a <code class="literal">PessimisticLockingFailureException</code> we simply try again
unless we have exhausted all of our retry attempts.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>This class is identical to the one used in the @AspectJ example, but with the
annotations removed.</p>
</td></tr></tbody></table></div>
<p>The corresponding Spring configuration is:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

    <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationRetry"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"concurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"idempotentOperation"</span>
            <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

        <span class="hl-tag">&lt;aop:around</span>
            <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"idempotentOperation"</span>
            <span class="hl-attribute">method</span>=<span class="hl-value">"doConcurrentOperation"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationExecutor"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxRetries"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Notice that for the time being we assume that all business services are idempotent. If
this is not the case we can refine the aspect so that it only retries genuinely
idempotent operations, by introducing an <code class="literal">Idempotent</code> annotation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> Idempotent {
    <span class="hl-comment">// marker annotation</span>
}</pre>
<p>and using the annotation to annotate the implementation of service operations. The
change to the aspect to retry only idempotent operations simply involves refining the
pointcut expression so that only <code class="literal">@Idempotent</code> operations match:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"idempotentOperation"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) and
        @annotation(com.xyz.myapp.service.Idempotent)"</span><span class="hl-tag">/&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-choosing" href="#aop-choosing"></a>11.4 Choosing which AOP declaration style to use</h2></div></div></div>
<p>Once you have decided that an aspect is the best approach for implementing a given
requirement, how do you decide between using Spring AOP or AspectJ, and between the
Aspect language (code) style, @AspectJ annotation style, or the Spring XML style? These
decisions are influenced by a number of factors including application requirements,
development tools, and team familiarity with AOP.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-spring-or-aspectj" href="#aop-spring-or-aspectj"></a>11.4.1 Spring AOP or full AspectJ?</h3></div></div></div>
<p>Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ as
there is no requirement to introduce the AspectJ compiler / weaver into your development
and build processes. If you only need to advise the execution of operations on Spring
beans, then Spring AOP is the right choice. If you need to advise objects not managed by
the Spring container (such as domain objects typically), then you will need to use
AspectJ. You will also need to use AspectJ if you wish to advise join points other than
simple method executions (for example, field get or set join points, and so on).</p>
<p>When using AspectJ, you have the choice of the AspectJ language syntax (also known as
the "code style") or the @AspectJ annotation style. Clearly, if you are not using Java
5+ then the choice has been made for you…​ use the code style. If aspects play a large
role in your design, and you are able to use the <a class="ulink" href="https://www.eclipse.org/ajdt/" target="_top">AspectJ
Development Tools (AJDT)</a> plugin for Eclipse, then the AspectJ language syntax is the
preferred option: it is cleaner and simpler because the language was purposefully
designed for writing aspects. If you are not using Eclipse, or have only a few aspects
that do not play a major role in your application, then you may want to consider using
the @AspectJ style and sticking with a regular Java compilation in your IDE, and adding
an aspect weaving phase to your build script.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-or-xml" href="#aop-ataspectj-or-xml"></a>11.4.2 @AspectJ or XML for Spring AOP?</h3></div></div></div>
<p>If you have chosen to use Spring AOP, then you have a choice of @AspectJ or XML style.
There are various tradeoffs to consider.</p>
<p>The XML style will be most familiar to existing Spring users and it is backed by genuine
POJOs. When using AOP as a tool to configure enterprise services then XML can be a good
choice (a good test is whether you consider the pointcut expression to be a part of your
configuration you might want to change independently). With the XML style arguably it is
clearer from your configuration what aspects are present in the system.</p>
<p>The XML style has two disadvantages. Firstly it does not fully encapsulate the
implementation of the requirement it addresses in a single place. The DRY principle says
that there should be a single, unambiguous, authoritative representation of any piece of
knowledge within a system. When using the XML style, the knowledge of <span class="emphasis"><em>how</em></span> a
requirement is implemented is split across the declaration of the backing bean class,
and the XML in the configuration file. When using the @AspectJ style there is a single
module - the aspect - in which this information is encapsulated. Secondly, the XML style
is slightly more limited in what it can express than the @AspectJ style: only the
"singleton" aspect instantiation model is supported, and it is not possible to combine
named pointcuts declared in XML. For example, in the @AspectJ style you can write
something like:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Pointcut(execution(* get*()))</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> propertyAccess() {}

@Pointcut(execution(org.xyz.Account+ *(..))
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> operationReturningAnAccount() {}

<em><span class="hl-annotation" style="color: gray">@Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount())</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> accountPropertyAccess() {}</pre>
<p>In the XML style I can declare the first two pointcuts:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"propertyAccess"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* get*())"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"operationReturningAnAccount"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(org.xyz.Account+ *(..))"</span><span class="hl-tag">/&gt;</span></pre>
<p>The downside of the XML approach is that you cannot define the
<code class="literal">accountPropertyAccess</code> pointcut by combining these definitions.</p>
<p>The @AspectJ style supports additional instantiation models, and richer pointcut
composition. It has the advantage of keeping the aspect as a modular unit. It also has
the advantage the @AspectJ aspects can be understood (and thus consumed) both by Spring
AOP and by AspectJ - so if you later decide you need the capabilities of AspectJ to
implement additional requirements then it is very easy to migrate to an AspectJ-based
approach. On balance the Spring team prefer the @AspectJ style whenever you have aspects
that do more than simple "configuration" of enterprise services.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-mixing-styles" href="#aop-mixing-styles"></a>11.5 Mixing aspect types</h2></div></div></div>
<p>It is perfectly possible to mix @AspectJ style aspects using the autoproxying support,
schema-defined <code class="literal">&lt;aop:aspect&gt;</code> aspects, <code class="literal">&lt;aop:advisor&gt;</code> declared advisors and even
proxies and interceptors defined using the Spring 1.2 style in the same configuration.
All of these are implemented using the same underlying support mechanism and will
co-exist without any difficulty.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-proxying" href="#aop-proxying"></a>11.6 Proxying mechanisms</h2></div></div></div>
<p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given
target object. (JDK dynamic proxies are preferred whenever you have a choice).</p>
<p>If the target object to be proxied implements at least one interface then a JDK dynamic
proxy will be used. All of the interfaces implemented by the target type will be
proxied. If the target object does not implement any interfaces then a CGLIB proxy will
be created.</p>
<p>If you want to force the use of CGLIB proxying (for example, to proxy every method
defined for the target object, not just those implemented by its interfaces) you can do
so. However, there are some issues to consider:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">final</code> methods cannot be advised, as they cannot be overridden.
</li><li class="listitem">
As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as
CGLIB classes are repackaged under org.springframework and included directly in the
spring-core JAR. This means that CGLIB-based proxy support 'just works' in the same
way that JDK dynamic proxies always have.
</li><li class="listitem">
As of Spring 4.0, the constructor of your proxied object will NOT be called twice
anymore since the CGLIB proxy instance will be created via Objenesis. Only if your
JVM does not allow for constructor bypassing, you might see double invocations and
corresponding debug log entries from Spring’s AOP support.
</li></ul></div>
<p>To force the use of CGLIB proxies set the value of the <code class="literal">proxy-target-class</code> attribute of
the <code class="literal">&lt;aop:config&gt;</code> element to true:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config</span> <span class="hl-attribute">proxy-target-class</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- other beans defined here... --&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span></pre>
<p>To force CGLIB proxying when using the @AspectJ autoproxy support, set the
<code class="literal">'proxy-target-class'</code> attribute of the <code class="literal">&lt;aop:aspectj-autoproxy&gt;</code> element to <code class="literal">true</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy</span> <span class="hl-attribute">proxy-target-class</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Multiple <code class="literal">&lt;aop:config/&gt;</code> sections are collapsed into a single unified auto-proxy creator
at runtime, which applies the <span class="emphasis"><em>strongest</em></span> proxy settings that any of the
<code class="literal">&lt;aop:config/&gt;</code> sections (typically from different XML bean definition files) specified.
This also applies to the <code class="literal">&lt;tx:annotation-driven/&gt;</code> and <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code>
elements.</p>
<p>To be clear: using <code class="literal">proxy-target-class="true"</code> on <code class="literal">&lt;tx:annotation-driven/&gt;</code>,
<code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> or <code class="literal">&lt;aop:config/&gt;</code> elements will force the use of CGLIB
proxies <span class="emphasis"><em>for all three of them</em></span>.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-understanding-aop-proxies" href="#aop-understanding-aop-proxies"></a>11.6.1 Understanding AOP proxies</h3></div></div></div>
<p>Spring AOP is <span class="emphasis"><em>proxy-based</em></span>. It is vitally important that you grasp the semantics of
what that last statement actually means before you write your own aspects or use any of
the Spring AOP-based aspects supplied with the Spring Framework.</p>
<p>Consider first the scenario where you have a plain-vanilla, un-proxied,
nothing-special-about-it, straight object reference, as illustrated by the following
code snippet.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimplePojo <span class="hl-keyword">implements</span> Pojo {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo() {
        <span class="hl-comment">// this next method invocation is a direct call on the 'this' reference</span>
        <span class="hl-keyword">this</span>.bar();
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar() {
        <span class="hl-comment">// some logic...</span>
    }
}</pre>
<p>If you invoke a method on an object reference, the method is invoked <span class="emphasis"><em>directly</em></span> on
that object reference, as can be seen below.</p>
<div class="informalfigure">
<div class="mediaobject"><img data-savepage-src="images/aop-proxy-plain-pojo-call.png" src="data:image/png;base64,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" alt="aop proxy plain pojo call"></div>
</div>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        Pojo pojo = <span class="hl-keyword">new</span> SimplePojo();

        <span class="hl-comment">// this is a direct method call on the 'pojo' reference</span>
        pojo.foo();
    }
}</pre>
<p>Things change slightly when the reference that client code has is a proxy. Consider the
following diagram and code snippet.</p>
<div class="informalfigure">
<div class="mediaobject"><img data-savepage-src="images/aop-proxy-call.png" src="data:image/png;base64,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" alt="aop proxy call"></div>
</div>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        ProxyFactory factory = <span class="hl-keyword">new</span> ProxyFactory(<span class="hl-keyword">new</span> SimplePojo());
        factory.addInterface(Pojo.<span class="hl-keyword">class</span>);
        factory.addAdvice(<span class="hl-keyword">new</span> RetryAdvice());

        Pojo pojo = (Pojo) factory.getProxy();

        <span class="hl-comment">// this is a method call on the proxy!</span>
        pojo.foo();
    }
}</pre>
<p>The key thing to understand here is that the client code inside the <code class="literal">main(..)</code> of the
<code class="literal">Main</code> class <span class="emphasis"><em>has a reference to the proxy</em></span>. This means that method calls on that
object reference will be calls on the proxy, and as such the proxy will be able to
delegate to all of the interceptors (advice) that are relevant to that particular method
call. However, once the call has finally reached the target object, the <code class="literal">SimplePojo</code>
reference in this case, any method calls that it may make on itself, such as
<code class="literal">this.bar()</code> or <code class="literal">this.foo()</code>, are going to be invoked against the <span class="emphasis"><em>this</em></span> reference,
and <span class="emphasis"><em>not</em></span> the proxy. This has important implications. It means that self-invocation is
<span class="emphasis"><em>not</em></span> going to result in the advice associated with a method invocation getting a
chance to execute.</p>
<p>Okay, so what is to be done about this? The best approach (the term best is used loosely
here) is to refactor your code such that the self-invocation does not happen. For sure,
this does entail some work on your part, but it is the best, least-invasive approach.
The next approach is absolutely horrendous, and I am almost reticent to point it out
precisely because it is so horrendous. You can (choke!) totally tie the logic within
your class to Spring AOP by doing this:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimplePojo <span class="hl-keyword">implements</span> Pojo {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo() {
        <span class="hl-comment">// this works, but... gah!</span>
        ((Pojo) AopContext.currentProxy()).bar();
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar() {
        <span class="hl-comment">// some logic...</span>
    }
}</pre>
<p>This totally couples your code to Spring AOP, <span class="emphasis"><em>and</em></span> it makes the class itself aware of
the fact that it is being used in an AOP context, which flies in the face of AOP. It
also requires some additional configuration when the proxy is being created:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        ProxyFactory factory = <span class="hl-keyword">new</span> ProxyFactory(<span class="hl-keyword">new</span> SimplePojo());
        factory.adddInterface(Pojo.<span class="hl-keyword">class</span>);
        factory.addAdvice(<span class="hl-keyword">new</span> RetryAdvice());
        factory.setExposeProxy(true);

        Pojo pojo = (Pojo) factory.getProxy();

        <span class="hl-comment">// this is a method call on the proxy!</span>
        pojo.foo();
    }
}</pre>
<p>Finally, it must be noted that AspectJ does not have this self-invocation issue because
it is not a proxy-based AOP framework.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-aspectj-programmatic" href="#aop-aspectj-programmatic"></a>11.7 Programmatic creation of @AspectJ Proxies</h2></div></div></div>
<p>In addition to declaring aspects in your configuration using either <code class="literal">&lt;aop:config&gt;</code> or
<code class="literal">&lt;aop:aspectj-autoproxy&gt;</code>, it is also possible programmatically to create proxies that
advise target objects. For the full details of Spring’s AOP API, see the next chapter.
Here we want to focus on the ability to automatically create proxies using @AspectJ
aspects.</p>
<p>The class <code class="literal">org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> can be used
to create a proxy for a target object that is advised by one or more @AspectJ aspects.
Basic usage for this class is very simple, as illustrated below. See the javadocs for
full information.</p>
<pre class="programlisting"><span class="hl-comment">// create a factory that can generate a proxy for the given target object</span>
AspectJProxyFactory factory = <span class="hl-keyword">new</span> AspectJProxyFactory(targetObject);

<span class="hl-comment">// add an aspect, the class must be an @AspectJ aspect</span>
<span class="hl-comment">// you can call this as many times as you need with different aspects</span>
factory.addAspect(SecurityManager.<span class="hl-keyword">class</span>);

<span class="hl-comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span>
factory.addAspect(usageTracker);

<span class="hl-comment">// now get the proxy object...</span>
MyInterfaceType proxy = factory.getProxy();</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-using-aspectj" href="#aop-using-aspectj"></a>11.8 Using AspectJ with Spring applications</h2></div></div></div>
<p>Everything we’ve covered so far in this chapter is pure Spring AOP. In this section,
we’re going to look at how you can use the AspectJ compiler/weaver instead of, or in
addition to, Spring AOP if your needs go beyond the facilities offered by Spring AOP
alone.</p>
<p>Spring ships with a small AspectJ aspect library, which is available standalone in your
distribution as <code class="literal">spring-aspects.jar</code>; you’ll need to add this to your classpath in order
to use the aspects in it. <a class="xref" href="aop.html#aop-atconfigurable" title="11.8.1 Using AspectJ to dependency inject domain objects with Spring">Section 11.8.1, “Using AspectJ to dependency inject domain objects with Spring”</a> and <a class="xref" href="aop.html#aop-ajlib-other" title="11.8.2 Other Spring aspects for AspectJ">Section 11.8.2, “Other Spring aspects for AspectJ”</a> discuss the
content of this library and how you can use it. <a class="xref" href="aop.html#aop-aj-configure" title="11.8.3 Configuring AspectJ aspects using Spring IoC">Section 11.8.3, “Configuring AspectJ aspects using Spring IoC”</a> discusses how to
dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,
<a class="xref" href="aop.html#aop-aj-ltw" title="11.8.4 Load-time weaving with AspectJ in the Spring Framework">Section 11.8.4, “Load-time weaving with AspectJ in the Spring Framework”</a> provides an introduction to load-time weaving for Spring applications
using AspectJ.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-atconfigurable" href="#aop-atconfigurable"></a>11.8.1 Using AspectJ to dependency inject domain objects with Spring</h3></div></div></div>
<p>The Spring container instantiates and configures beans defined in your application
context. It is also possible to ask a bean factory to configure a <span class="emphasis"><em>pre-existing</em></span>
object given the name of a bean definition containing the configuration to be applied.
The <code class="literal">spring-aspects.jar</code> contains an annotation-driven aspect that exploits this
capability to allow dependency injection of <span class="emphasis"><em>any object</em></span>. The support is intended to
be used for objects created <span class="emphasis"><em>outside of the control of any container</em></span>. Domain objects
often fall into this category because they are often created programmatically using the
<code class="literal">new</code> operator, or by an ORM tool as a result of a database query.</p>
<p>The <code class="literal">@Configurable</code> annotation marks a class as eligible for Spring-driven
configuration. In the simplest case it can be used just as a marker annotation:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.myapp.domain;

<span class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Configurable;

<em><span class="hl-annotation" style="color: gray">@Configurable</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Account {
    <span class="hl-comment">// ...</span>
}</pre>
<p>When used as a marker interface in this way, Spring will configure new instances of the
annotated type ( <code class="literal">Account</code> in this case) using a bean definition (typically
prototype-scoped) with the same name as the fully-qualified type name (
<code class="literal">com.xyz.myapp.domain.Account</code>). Since the default name for a bean is the
fully-qualified name of its type, a convenient way to declare the prototype definition
is simply to omit the <code class="literal">id</code> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.domain.Account"</span> <span class="hl-attribute">scope</span>=<span class="hl-value">"prototype"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fundsTransferService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"fundsTransferService"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>If you want to explicitly specify the name of the prototype bean definition to use, you
can do so directly in the annotation:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.myapp.domain;

<span class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Configurable;

<em><span class="hl-annotation" style="color: gray">@Configurable("account")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Account {
    <span class="hl-comment">// ...</span>
}</pre>
<p>Spring will now look for a bean definition named "account" and use that as the
definition to configure new <code class="literal">Account</code> instances.</p>
<p>You can also use autowiring to avoid having to specify a dedicated bean definition at
all. To have Spring apply autowiring use the <code class="literal">autowire</code> property of the
<code class="literal">@Configurable</code> annotation: specify either <code class="literal">@Configurable(autowire=Autowire.BY_TYPE)</code> or
<code class="literal">@Configurable(autowire=Autowire.BY_NAME</code> for autowiring by type or by name
respectively. As an alternative, as of Spring 2.5 it is preferable to specify explicit,
annotation-driven dependency injection for your <code class="literal">@Configurable</code> beans by using
<code class="literal">@Autowired</code> or <code class="literal">@Inject</code> at the field or method level (see <a class="xref" href="beans.html#beans-annotation-config" title="7.9 Annotation-based container configuration">Section 7.9, “Annotation-based container configuration”</a>
for further details).</p>
<p>Finally you can enable Spring dependency checking for the object references in the newly
created and configured object by using the <code class="literal">dependencyCheck</code> attribute (for example:
<code class="literal">@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>). If this attribute is
set to true, then Spring will validate after configuration that all properties (<span class="emphasis"><em>which
are not primitives or collections</em></span>) have been set.</p>
<p>Using the annotation on its own does nothing of course. It is the
<code class="literal">AnnotationBeanConfigurerAspect</code> in <code class="literal">spring-aspects.jar</code> that acts on the presence of
the annotation. In essence the aspect says "after returning from the initialization of a
new object of a type annotated with <code class="literal">@Configurable</code>, configure the newly created object
using Spring in accordance with the properties of the annotation". In this context,
<span class="emphasis"><em>initialization</em></span> refers to newly instantiated objects (e.g., objects instantiated with
the <code class="literal">new</code> operator) as well as to <code class="literal">Serializable</code> objects that are undergoing
deserialization (e.g., via
<a class="ulink" href="https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" target="_top">readResolve()</a>).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>One of the key phrases in the above paragraph is '<span class="emphasis"><em>in essence</em></span>'. For most cases, the
exact semantics of '<span class="emphasis"><em>after returning from the initialization of a new object</em></span>' will be
fine…​ in this context, '<span class="emphasis"><em>after initialization</em></span>' means that the dependencies will be
injected <span class="emphasis"><em>after</em></span> the object has been constructed - this means that the dependencies
will not be available for use in the constructor bodies of the class. If you want the
dependencies to be injected <span class="emphasis"><em>before</em></span> the constructor bodies execute, and thus be
available for use in the body of the constructors, then you need to define this on the
<code class="literal">@Configurable</code> declaration like so:</p>
<pre class="programlisting">@Configurable(preConstruction=true)</pre>
<p>You can find out more information about the language semantics of the various pointcut
types in AspectJ
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html" target="_top">in this
appendix</a> of the <a class="ulink" href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html" target="_top">AspectJ
Programming Guide</a>.</p>
</td></tr></tbody></table></div>
<p>For this to work the annotated types must be woven with the AspectJ weaver - you can
either use a build-time Ant or Maven task to do this (see for example the
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html" target="_top">AspectJ Development
Environment Guide</a>) or load-time weaving (see <a class="xref" href="aop.html#aop-aj-ltw" title="11.8.4 Load-time weaving with AspectJ in the Spring Framework">Section 11.8.4, “Load-time weaving with AspectJ in the Spring Framework”</a>). The
<code class="literal">AnnotationBeanConfigurerAspect</code> itself needs configuring by Spring (in order to obtain
a reference to the bean factory that is to be used to configure new objects). If you are
using Java based configuration simply add <code class="literal">@EnableSpringConfigured</code> to any
<code class="literal">@Configuration</code> class.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableSpringConfigured</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>
<p>If you prefer XML based configuration, the Spring <a class="link" href="xsd-configuration.html#xsd-config-body-schemas-context" title="41.2.8 the context schema"><code class="literal">context</code> namespace</a> defines a convenient <code class="literal">context:spring-configured</code> element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;context:spring-configured/&gt;</span></pre>
<p>Instances of <code class="literal">@Configurable</code> objects created <span class="emphasis"><em>before</em></span> the aspect has been configured
will result in a message being issued to the debug log and no configuration of the
object taking place. An example might be a bean in the Spring configuration that creates
domain objects when it is initialized by Spring. In this case you can use the
"depends-on" bean attribute to manually specify that the bean depends on the
configuration aspect.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myService"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.xzy.myapp.service.MyService"</span>
        <span class="hl-attribute">depends-on</span>=<span class="hl-value">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- ... --&gt;</span>

<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Do not activate <code class="literal">@Configurable</code> processing through the bean configurer aspect unless you
really mean to rely on its semantics at runtime. In particular, make sure that you do
not use <code class="literal">@Configurable</code> on bean classes which are registered as regular Spring beans
with the container: You would get double initialization otherwise, once through the
container and once through the aspect.</p>
</td></tr></tbody></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-testing" href="#aop-configurable-testing"></a>Unit testing @Configurable objects</h4></div></div></div>
<p>One of the goals of the <code class="literal">@Configurable</code> support is to enable independent unit testing of
domain objects without the difficulties associated with hard-coded lookups. If
<code class="literal">@Configurable</code> types have not been woven by AspectJ then the annotation has no affect
during unit testing, and you can simply set mock or stub property references in the
object under test and proceed as normal. If <code class="literal">@Configurable</code> types <span class="emphasis"><em>have</em></span> been woven by
AspectJ then you can still unit test outside of the container as normal, but you will
see a warning message each time that you construct an <code class="literal">@Configurable</code> object indicating
that it has not been configured by Spring.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-container" href="#aop-configurable-container"></a>Working with multiple application contexts</h4></div></div></div>
<p>The <code class="literal">AnnotationBeanConfigurerAspect</code> used to implement the <code class="literal">@Configurable</code> support is an
AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of
<code class="literal">static</code> members, that is to say there is one aspect instance per classloader that
defines the type. This means that if you define multiple application contexts within the
same classloader hierarchy you need to consider where to define the
<code class="literal">@EnableSpringConfigured</code> bean and where to place <code class="literal">spring-aspects.jar</code> on the classpath.</p>
<p>Consider a typical Spring web-app configuration with a shared parent application context
defining common business services and everything needed to support them, and one child
application context per servlet containing definitions particular to that servlet. All
of these contexts will co-exist within the same classloader hierarchy, and so the
<code class="literal">AnnotationBeanConfigurerAspect</code> can only hold a reference to one of them. In this case
we recommend defining the <code class="literal">@EnableSpringConfigured</code> bean in the shared (parent)
application context: this defines the services that you are likely to want to inject
into domain objects. A consequence is that you cannot configure domain objects with
references to beans defined in the child (servlet-specific) contexts using the
@Configurable mechanism (probably not something you want to do anyway!).</p>
<p>When deploying multiple web-apps within the same container, ensure that each
web-application loads the types in <code class="literal">spring-aspects.jar</code> using its own classloader (for
example, by placing <code class="literal">spring-aspects.jar</code> in <code class="literal">'WEB-INF/lib'</code>). If <code class="literal">spring-aspects.jar</code> is
only added to the container wide classpath (and hence loaded by the shared parent
classloader), all web applications will share the same aspect instance which is probably
not what you want.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ajlib-other" href="#aop-ajlib-other"></a>11.8.2 Other Spring aspects for AspectJ</h3></div></div></div>
<p>In addition to the <code class="literal">@Configurable</code> aspect, <code class="literal">spring-aspects.jar</code> contains an AspectJ
aspect that can be used to drive Spring’s transaction management for types and methods
annotated with the <code class="literal">@Transactional</code> annotation. This is primarily intended for users who
want to use the Spring Framework’s transaction support outside of the Spring container.</p>
<p>The aspect that interprets <code class="literal">@Transactional</code> annotations is the
<code class="literal">AnnotationTransactionAspect</code>. When using this aspect, you must annotate the
<span class="emphasis"><em>implementation</em></span> class (and/or methods within that class), <span class="emphasis"><em>not</em></span> the interface (if
any) that the class implements. AspectJ follows Java’s rule that annotations on
interfaces are <span class="emphasis"><em>not inherited</em></span>.</p>
<p>A <code class="literal">@Transactional</code> annotation on a class specifies the default transaction semantics for
the execution of any <span class="emphasis"><em>public</em></span> operation in the class.</p>
<p>A <code class="literal">@Transactional</code> annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). Methods of any
visibility may be annotated, including private methods. Annotating non-public methods
directly is the only way to get transaction demarcation for the execution of such methods.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Tip]" data-savepage-src="images/tip.png" src="data:image/png;resource=8;base64,"></td><th align="left">Tip</th></tr><tr><td valign="top" align="left">
<p>Since Spring Framework 4.2, <code class="literal">spring-aspects</code> provides a similar aspect that offers the
exact same features for the standard <code class="literal">javax.transaction.Transactional</code> annotation. Check
<code class="literal">JtaAnnotationTransactionAspect</code> for more details.</p>
</td></tr></tbody></table></div>
<p>For AspectJ programmers that want to use the Spring configuration and transaction
management support but don’t want to (or cannot) use annotations, <code class="literal">spring-aspects.jar</code>
also contains <code class="literal">abstract</code> aspects you can extend to provide your own pointcut
definitions. See the sources for the <code class="literal">AbstractBeanConfigurerAspect</code> and
<code class="literal">AbstractTransactionAspect</code> aspects for more information. As an example, the following
excerpt shows how you could write an aspect to configure all instances of objects
defined in the domain model using prototype bean definitions that match the
fully-qualified class names:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> aspect DomainObjectConfiguration <span class="hl-keyword">extends</span> AbstractBeanConfigurerAspect {

    <span class="hl-keyword">public</span> DomainObjectConfiguration() {
        setBeanWiringInfoResolver(<span class="hl-keyword">new</span> ClassNameBeanWiringInfoResolver());
    }

    <span class="hl-comment">// the creation of a new bean (any object in the domain model)</span>
    <span class="hl-keyword">protected</span> pointcut beanCreation(Object beanInstance) :
        initialization(<span class="hl-keyword">new</span>(..)) &amp;&amp;
        SystemArchitecture.inDomainModel() &amp;&amp;
        <span class="hl-keyword">this</span>(beanInstance);

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-configure" href="#aop-aj-configure"></a>11.8.3 Configuring AspectJ aspects using Spring IoC</h3></div></div></div>
<p>When using AspectJ aspects with Spring applications, it is natural to both want and
expect to be able to configure such aspects using Spring. The AspectJ runtime itself is
responsible for aspect creation, and the means of configuring the AspectJ created
aspects via Spring depends on the AspectJ instantiation model (the <code class="literal">per-xxx</code> clause)
used by the aspect.</p>
<p>The majority of AspectJ aspects are <span class="emphasis"><em>singleton</em></span> aspects. Configuration of these
aspects is very easy: simply create a bean definition referencing the aspect type as
normal, and include the bean attribute <code class="literal">'factory-method="aspectOf"'</code>. This ensures that
Spring obtains the aspect instance by asking AspectJ for it rather than trying to create
an instance itself. For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"profiler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.profiler.Profiler"</span>
        <span class="strong"><strong>factory-method="aspectOf"</strong></span>&gt;

    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"profilingStrategy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jamonProfilingStrategy"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Non-singleton aspects are harder to configure: however it is possible to do so by
creating prototype bean definitions and using the <code class="literal">@Configurable</code> support from
<code class="literal">spring-aspects.jar</code> to configure the aspect instances once they have bean created by
the AspectJ runtime.</p>
<p>If you have some @AspectJ aspects that you want to weave with AspectJ (for example,
using load-time weaving for domain model types) and other @AspectJ aspects that you want
to use with Spring AOP, and these aspects are all configured using Spring, then you will
need to tell the Spring AOP @AspectJ autoproxying support which exact subset of the
@AspectJ aspects defined in the configuration should be used for autoproxying. You can
do this by using one or more <code class="literal">&lt;include/&gt;</code> elements inside the <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code>
declaration. Each <code class="literal">&lt;include/&gt;</code> element specifies a name pattern, and only beans with
names matched by at least one of the patterns will be used for Spring AOP autoproxy
configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy&gt;</span>
    <span class="hl-tag">&lt;aop:include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thisBean"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;aop:include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thatBean"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/aop:aspectj-autoproxy&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>Do not be misled by the name of the <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> element: using it will
result in the creation of <span class="emphasis"><em>Spring AOP proxies</em></span>. The @AspectJ style of aspect
declaration is just being used here, but the AspectJ runtime is <span class="emphasis"><em>not</em></span> involved.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-ltw" href="#aop-aj-ltw"></a>11.8.4 Load-time weaving with AspectJ in the Spring Framework</h3></div></div></div>
<p>Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an
application’s class files as they are being loaded into the Java virtual machine (JVM).
The focus of this section is on configuring and using LTW in the specific context of the
Spring Framework: this section is not an introduction to LTW though. For full details on
the specifics of LTW and configuring LTW with just AspectJ (with Spring not being
involved at all), see the
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html" target="_top">LTW section of the AspectJ
Development Environment Guide</a>.</p>
<p>The value-add that the Spring Framework brings to AspectJ LTW is in enabling much
finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected using
a Java (5+) agent, which is switched on by specifying a VM argument when starting up a
JVM. It is thus a JVM-wide setting, which may be fine in some situations, but often is a
little too coarse. Spring-enabled LTW enables you to switch on LTW on a
<span class="emphasis"><em>per-ClassLoader</em></span> basis, which obviously is more fine-grained and which can make more
sense in a 'single-JVM-multiple-application' environment (such as is found in a typical
application server environment).</p>
<p>Further, <a class="link" href="aop.html#aop-aj-ltw-environments" title="Environment-specific configuration">in certain environments</a>, this support enables
load-time weaving <span class="emphasis"><em>without making any modifications to the application server’s launch
script</em></span> that will be needed to add <code class="literal">-javaagent:path/to/aspectjweaver.jar</code> or (as we
describe later in this section)
<code class="literal">-javaagent:path/to/org.springframework.instrument-{version}.jar</code> (previously named
<code class="literal">spring-agent.jar</code>). Developers simply modify one or more files that form the
application context to enable load-time weaving instead of relying on administrators who
typically are in charge of the deployment configuration such as the launch script.</p>
<p>Now that the sales pitch is over, let us first walk through a quick example of AspectJ
LTW using Spring, followed by detailed specifics about elements introduced in the
following example. For a complete example, please see the
<a class="ulink" href="https://github.com/spring-projects/spring-petclinic" target="_top">Petclinic sample application</a>.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-first-example" href="#aop-aj-ltw-first-example"></a>A first example</h4></div></div></div>
<p>Let us assume that you are an application developer who has been tasked with diagnosing
the cause of some performance problems in a system. Rather than break out a profiling
tool, what we are going to do is switch on a simple profiling aspect that will enable us
to very quickly get some performance metrics, so that we can then apply a finer-grained
profiling tool to that specific area immediately afterwards.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>The example presented here uses XML style configuration, it is also possible to
configure and use @AspectJ with <a class="link" href="beans.html#beans-java" title="7.12 Java-based container configuration">Java Configuration</a>. Specifically the
<code class="literal">@EnableLoadTimeWeaving</code> annotation can be used as an alternative to
<code class="literal">&lt;context:load-time-weaver/&gt;</code> (see <a class="link" href="aop.html#aop-aj-ltw-spring" title="Spring configuration">below</a> for details).</p>
</td></tr></tbody></table></div>
<p>Here is the profiling aspect. Nothing too fancy, just a quick-and-dirty time-based
profiler, using the @AspectJ-style of aspect declaration.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Around;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Pointcut;
<span class="hl-keyword">import</span> org.springframework.util.StopWatch;
<span class="hl-keyword">import</span> org.springframework.core.annotation.Order;

<em><span class="hl-annotation" style="color: gray">@Aspect</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProfilingAspect {

    <em><span class="hl-annotation" style="color: gray">@Around("methodsToBeProfiled()")</span></em>
    <span class="hl-keyword">public</span> Object profile(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
        StopWatch sw = <span class="hl-keyword">new</span> StopWatch(getClass().getSimpleName());
        <span class="hl-keyword">try</span> {
            sw.start(pjp.getSignature().getName());
            <span class="hl-keyword">return</span> pjp.proceed();
        } <span class="hl-keyword">finally</span> {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Pointcut("execution(public * foo..*.*(..))")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> methodsToBeProfiled(){}
}</pre>
<p>We will also need to create an <code class="literal">META-INF/aop.xml</code> file, to inform the AspectJ weaver
that we want to weave our <code class="literal">ProfilingAspect</code> into our classes. This file convention,
namely the presence of a file (or files) on the Java classpath called
<code class="literal">META-INF/aop.xml</code> is standard AspectJ.</p>
<pre class="programlisting"><strong class="hl-tag" style="color: blue">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;</strong>
<span class="hl-tag">&lt;aspectj&gt;</span>

    <span class="hl-tag">&lt;weaver&gt;</span>
        <span class="hl-comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span>
        <span class="hl-tag">&lt;include</span> <span class="hl-attribute">within</span>=<span class="hl-value">"foo.*"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/weaver&gt;</span>

    <span class="hl-tag">&lt;aspects&gt;</span>
        <span class="hl-comment">&lt;!-- weave in just this aspect --&gt;</span>
        <span class="hl-tag">&lt;aspect</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo.ProfilingAspect"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aspects&gt;</span>

<span class="hl-tag">&lt;/aspectj&gt;</span></pre>
<p>Now to the Spring-specific portion of the configuration. We need to configure a
<code class="literal">LoadTimeWeaver</code> (all explained later, just take it on trust for now). This load-time
weaver is the essential component responsible for weaving the aspect configuration in
one or more <code class="literal">META-INF/aop.xml</code> files into the classes in your application. The good
thing is that it does not require a lot of configuration, as can be seen below (there
are some more options that you can specify, but these are detailed later).</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"entitlementCalculationService"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"foo.StubEntitlementCalculationService"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- this switches on the load-time weaving --&gt;</span>
    <span class="strong"><strong>&lt;context:load-time-weaver/&gt;</strong></span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>Now that all the required artifacts are in place - the aspect, the <code class="literal">META-INF/aop.xml</code>
file, and the Spring configuration -, let us create a simple driver class with a
<code class="literal">main(..)</code> method to demonstrate the LTW in action.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        ApplicationContext ctx = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"beans.xml"</span>, Main.<span class="hl-keyword">class</span>);

        EntitlementCalculationService entitlementCalculationService
            = (EntitlementCalculationService) ctx.getBean(<span class="hl-string">"entitlementCalculationService"</span>);

        <span class="hl-comment">// the profiling aspect is 'woven' around this method execution</span>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre>
<p>There is one last thing to do. The introduction to this section did say that one could
switch on LTW selectively on a per- <code class="literal">ClassLoader</code> basis with Spring, and this is true.
However, just for this example, we are going to use a Java agent (supplied with Spring)
to switch on the LTW. This is the command line we will use to run the above <code class="literal">Main</code> class:</p>
<pre class="literallayout">java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
<p>The <code class="literal">-javaagent</code> is a flag for specifying and enabling
<a class="ulink" href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html" target="_top">agents
to instrument programs running on the JVM</a>. The Spring Framework ships with such an
agent, the <code class="literal">InstrumentationSavingAgent</code>, which is packaged in the
<code class="literal">spring-instrument.jar</code> that was supplied as the value of the <code class="literal">-javaagent</code> argument in
the above example.</p>
<p>The output from the execution of the <code class="literal">Main</code> program will look something like that below.
(I have introduced a <code class="literal">Thread.sleep(..)</code> statement into the <code class="literal">calculateEntitlement()</code>
implementation so that the profiler actually captures something other than 0
milliseconds - the <code class="literal">01234</code> milliseconds is <span class="emphasis"><em>not</em></span> an overhead introduced by the AOP :) )</p>
<pre class="literallayout">Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
<p>Since this LTW is effected using full-blown AspectJ, we are not just limited to advising
Spring beans; the following slight variation on the <code class="literal">Main</code> program will yield the same
result.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"beans.xml"</span>, Main.<span class="hl-keyword">class</span>);

        EntitlementCalculationService entitlementCalculationService =
            <span class="hl-keyword">new</span> StubEntitlementCalculationService();

        <span class="hl-comment">// the profiling aspect will be 'woven' around this method execution</span>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre>
<p>Notice how in the above program we are simply bootstrapping the Spring container, and
then creating a new instance of the <code class="literal">StubEntitlementCalculationService</code> totally outside
the context of Spring…​ the profiling advice still gets woven in.</p>
<p>The example admittedly is simplistic…​ however the basics of the LTW support in Spring
have all been introduced in the above example, and the rest of this section will explain
the 'why' behind each bit of configuration and usage in detail.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Note]" data-savepage-src="images/note.png" src="data:image/png;resource=4;base64,"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
<p>The <code class="literal">ProfilingAspect</code> used in this example may be basic, but it is quite useful. It is a
nice example of a development-time aspect that developers can use during development (of
course), and then quite easily exclude from builds of the application being deployed
into UAT or production.</p>
</td></tr></tbody></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-the-aspects" href="#aop-aj-ltw-the-aspects"></a>Aspects</h4></div></div></div>
<p>The aspects that you use in LTW have to be AspectJ aspects. They can be written in
either the AspectJ language itself or you can write your aspects in the @AspectJ-style.
It means that your aspects are then both valid AspectJ <span class="emphasis"><em>and</em></span> Spring AOP aspects.
Furthermore, the compiled aspect classes need to be available on the classpath.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-aop_dot_xml" href="#aop-aj-ltw-aop_dot_xml"></a>'META-INF/aop.xml'</h4></div></div></div>
<p>The AspectJ LTW infrastructure is configured using one or more <code class="literal">META-INF/aop.xml</code>
files, that are on the Java classpath (either directly, or more typically in jar files).</p>
<p>The structure and contents of this file is detailed in the main AspectJ reference
documentation, and the interested reader is
<a class="ulink" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html" target="_top">referred to
that resource</a>. (I appreciate that this section is brief, but the <code class="literal">aop.xml</code> file is
100% AspectJ - there is no Spring-specific information or semantics that apply to it,
and so there is no extra value that I can contribute either as a result), so rather than
rehash the quite satisfactory section that the AspectJ developers wrote, I am just
directing you there.)</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-libraries" href="#aop-aj-ltw-libraries"></a>Required libraries (JARS)</h4></div></div></div>
<p>At a minimum you will need the following libraries to use the Spring Framework’s support
for AspectJ LTW:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">spring-aop.jar</code> (version 2.5 or later, plus all mandatory dependencies)
</li><li class="listitem">
<code class="literal">aspectjweaver.jar</code> (version 1.6.8 or later)
</li></ul></div>
<p>If you are using the <a class="link" href="aop.html#aop-aj-ltw-environment-generic" title="Generic Java applications">Spring-provided agent to enable
instrumentation</a>, you will also need:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">spring-instrument.jar</code>
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-spring" href="#aop-aj-ltw-spring"></a>Spring configuration</h4></div></div></div>
<p>The key component in Spring’s LTW support is the <code class="literal">LoadTimeWeaver</code> interface (in the
<code class="literal">org.springframework.instrument.classloading</code> package), and the numerous implementations
of it that ship with the Spring distribution. A <code class="literal">LoadTimeWeaver</code> is responsible for
adding one or more <code class="literal">java.lang.instrument.ClassFileTransformers</code> to a <code class="literal">ClassLoader</code> at
runtime, which opens the door to all manner of interesting applications, one of which
happens to be the LTW of aspects.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Tip]" data-savepage-src="images/tip.png" src="data:image/png;resource=8;base64,"></td><th align="left">Tip</th></tr><tr><td valign="top" align="left">
<p>If you are unfamiliar with the idea of runtime class file transformation, you are
encouraged to read the javadoc API documentation for the <code class="literal">java.lang.instrument</code> package
before continuing. This is not a huge chore because there is - rather annoyingly -
precious little documentation there…​ the key interfaces and classes will at least be
laid out in front of you for reference as you read through this section.</p>
</td></tr></tbody></table></div>
<p>Configuring a <code class="literal">LoadTimeWeaver</code> for a particular <code class="literal">ApplicationContext</code> can be as easy as
adding one line. (Please note that you almost certainly will need to be using an
<code class="literal">ApplicationContext</code> as your Spring container - typically a <code class="literal">BeanFactory</code> will not be
enough because the LTW support makes use of <code class="literal">BeanFactoryPostProcessors</code>.)</p>
<p>To enable the Spring Framework’s LTW support, you need to configure a <code class="literal">LoadTimeWeaver</code>,
which typically is done using the <code class="literal">@EnableLoadTimeWeaving</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableLoadTimeWeaving</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>
<p>Alternatively, if you prefer XML based configuration, use the
<code class="literal">&lt;context:load-time-weaver/&gt;</code> element. Note that the element is defined in the
<code class="literal">context</code> namespace.</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;context:load-time-weaver/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>The above configuration will define and register a number of LTW-specific infrastructure
beans for you automatically, such as a <code class="literal">LoadTimeWeaver</code> and an <code class="literal">AspectJWeavingEnabler</code>.
The default <code class="literal">LoadTimeWeaver</code> is the <code class="literal">DefaultContextLoadTimeWeaver</code> class, which attempts
to decorate an automatically detected <code class="literal">LoadTimeWeaver</code>: the exact type of
<code class="literal">LoadTimeWeaver</code> that will be 'automatically detected' is dependent upon your runtime
environment (summarized in the following table).</p>
<div class="table"><a name="aop-aj-ltw-spring-env-impls" href="#aop-aj-ltw-spring-env-impls"></a><p class="title"><b>Table 11.1. DefaultContextLoadTimeWeaver LoadTimeWeavers</b></p><div class="table-contents">
<table summary="DefaultContextLoadTimeWeaver LoadTimeWeavers" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left">Runtime Environment</th><th style="border-bottom: 0.5pt solid ; " valign="top" align="left"><code class="literal">LoadTimeWeaver</code> implementation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>Running in Oracle’s
<a class="ulink" href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html" target="_top">WebLogic</a></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">WebLogicLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>Running in Oracle’s <a class="ulink" href="http://glassfish.dev.java.net/" target="_top">GlassFish</a></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">GlassFishLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>Running in <a class="ulink" href="https://tomcat.apache.org/" target="_top">Apache Tomcat</a></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">TomcatLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>Running in Red Hat’s <a class="ulink" href="http://www.jboss.org/jbossas/" target="_top">JBoss AS</a> or <a class="ulink" href="http://www.wildfly.org/" target="_top">WildFly</a></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">JBossLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>Running in IBM’s <a class="ulink" href="https://www-01.ibm.com/software/webservers/appserv/was/" target="_top">WebSphere</a></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">WebSphereLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p>JVM started with Spring <code class="literal">InstrumentationSavingAgent</code> <span class="emphasis"><em>(java
-javaagent:path/to/spring-instrument.jar)</em></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">InstrumentationLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top" align="left"><p>Fallback, expecting the underlying ClassLoader to follow common conventions (e.g.
applicable to <code class="literal">TomcatInstrumentableClassLoader</code> and <a class="ulink" href="http://www.caucho.com/" target="_top">Resin</a>)</p></td><td style="" valign="top" align="left"><p><code class="literal">ReflectiveLoadTimeWeaver</code></p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>Note that these are just the <code class="literal">LoadTimeWeavers</code> that are autodetected when using the
<code class="literal">DefaultContextLoadTimeWeaver</code>: it is of course possible to specify exactly which
<code class="literal">LoadTimeWeaver</code> implementation that you wish to use.</p>
<p>To specify a specific <code class="literal">LoadTimeWeaver</code> with Java configuration implement the
<code class="literal">LoadTimeWeavingConfigurer</code> interface and override the <code class="literal">getLoadTimeWeaver()</code> method:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableLoadTimeWeaving</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> LoadTimeWeavingConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> LoadTimeWeaver getLoadTimeWeaver() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ReflectiveLoadTimeWeaver();
    }
}</pre>
<p>If you are using XML based configuration you can specify the fully-qualified classname
as the value of the <code class="literal">weaver-class</code> attribute on the <code class="literal">&lt;context:load-time-weaver/&gt;</code>
element:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;context:load-time-weaver</span>
            <span class="hl-attribute">weaver-class</span>=<span class="hl-value">"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>The <code class="literal">LoadTimeWeaver</code> that is defined and registered by the configuration can be later
retrieved from the Spring container using the well-known name <code class="literal">loadTimeWeaver</code>.
Remember that the <code class="literal">LoadTimeWeaver</code> exists just as a mechanism for Spring’s LTW
infrastructure to add one or more <code class="literal">ClassFileTransformers</code>. The actual
<code class="literal">ClassFileTransformer</code> that does the LTW is the <code class="literal">ClassPreProcessorAgentAdapter</code> (from
the <code class="literal">org.aspectj.weaver.loadtime</code> package) class. See the class-level javadocs of the
<code class="literal">ClassPreProcessorAgentAdapter</code> class for further details, because the specifics of how
the weaving is actually effected is beyond the scope of this section.</p>
<p>There is one final attribute of the configuration left to discuss: the
<code class="literal">aspectjWeaving</code> attribute (or <code class="literal">aspectj-weaving</code> if you are using XML). This is a
simple attribute that controls whether LTW is enabled or not; it is as simple as that.
It accepts one of three possible values, summarized below, with the default value being
<code class="literal">autodetect</code> if the attribute is not present.</p>
<div class="table"><a name="aop-aj-ltw-ltw-tag-attrs" href="#aop-aj-ltw-ltw-tag-attrs"></a><p class="title"><b>Table 11.2. AspectJ weaving attribute values</b></p><div class="table-contents">
<table summary="AspectJ weaving attribute values" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left">Annotation Value</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left">XML Value</th><th style="border-bottom: 0.5pt solid ; " valign="top" align="left">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">ENABLED</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">on</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p>AspectJ weaving is on, and aspects will be woven at load-time as appropriate.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">DISABLED</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">off</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top" align="left"><p>LTW is off…​ no aspect will be woven at load-time.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">AUTODETECT</code></p></td><td style="border-right: 0.5pt solid ; " valign="top" align="left"><p><code class="literal">autodetect</code></p></td><td style="" valign="top" align="left"><p>If the Spring LTW infrastructure can find at least one <code class="literal">META-INF/aop.xml</code> file,
then AspectJ weaving is on, else it is off. This is the default value.</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-environments" href="#aop-aj-ltw-environments"></a>Environment-specific configuration</h4></div></div></div>
<p>This last section contains any additional settings and configuration that you will need
when using Spring’s LTW support in environments such as application servers and web
containers.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-tomcat" href="#aop-aj-ltw-environment-tomcat"></a>Tomcat</h5></div></div></div>
<p>Historically, <a class="ulink" href="https://tomcat.apache.org/" target="_top">Apache Tomcat</a>'s default class loader did not
support class transformation which is why Spring provides an enhanced implementation
that addresses this need. Named <code class="literal">TomcatInstrumentableClassLoader</code>, the loader works on
Tomcat 6.0 and above.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" width="25" valign="top" align="center"><img alt="[Tip]" data-savepage-src="images/tip.png" src="data:image/png;resource=8;base64,"></td><th align="left">Tip</th></tr><tr><td valign="top" align="left">
<p>Do not define <code class="literal">TomcatInstrumentableClassLoader</code> anymore on Tomcat 8.0 and higher.
Instead, let Spring automatically use Tomcat’s new native <code class="literal">InstrumentableClassLoader</code>
facility through the <code class="literal">TomcatLoadTimeWeaver</code> strategy.</p>
</td></tr></tbody></table></div>
<p>If you still need to use <code class="literal">TomcatInstrumentableClassLoader</code>, it can be registered
individually for <span class="emphasis"><em>each</em></span> web application as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Copy <code class="literal">org.springframework.instrument.tomcat.jar</code> into <span class="emphasis"><em>$CATALINA_HOME</em></span>/lib, where
<span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the Tomcat installation)
</li><li class="listitem">
Instruct Tomcat to use the custom class loader (instead of the default) by editing the
web application context file:
</li></ul></div>
<pre class="programlisting"><span class="hl-tag">&lt;Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/myWebApp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"/my/webApp/location"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;Loader</span>
        <span class="hl-attribute">loaderClass</span>=<span class="hl-value">"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/Context&gt;</span></pre>
<p>Apache Tomcat (6.0+) supports several context locations:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
server configuration file - <span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>
</li><li class="listitem">
default context configuration - <span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span> - that affects all
deployed web applications
</li><li class="listitem">
per-web application configuration which can be deployed either on the server-side at
<span class="emphasis"><em>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</em></span> or embedded
inside the web-app archive at <span class="emphasis"><em>META-INF/context.xml</em></span>
</li></ul></div>
<p>For efficiency, the embedded per-web-app configuration style is recommended because it
will impact only applications that use the custom class loader and does not require any
changes to the server configuration. See the Tomcat 6.0.x
<a class="ulink" href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html" target="_top">documentation</a> for more
details about available context locations.</p>
<p>Alternatively, consider the use of the Spring-provided generic VM agent, to be specified
in Tomcat’s launch script (see above). This will make instrumentation available to all
deployed web applications, no matter what ClassLoader they happen to run on.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss" href="#aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"></a>WebLogic, WebSphere, Resin, GlassFish, JBoss</h5></div></div></div>
<p>Recent versions of WebLogic Server (version 10 and above), IBM WebSphere Application
Server (version 7 and above), Resin (3.1 and above) and JBoss (6.x or above) provide a
ClassLoader that is capable of local instrumentation. Spring’s native LTW leverages such
ClassLoaders to enable AspectJ weaving. You can enable LTW by simply activating
load-time weaving as described earlier. Specifically, you do <span class="emphasis"><em>not</em></span> need to modify the
launch script to add <code class="literal">-javaagent:path/to/spring-instrument.jar</code>.</p>
<p>Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR
environment. For GlassFish web applications, follow the Tomcat setup instructions as
outlined above.</p>
<p>Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from
loading the classes before the application actually starts. A quick workaround is to add
to your artifact a file named <code class="literal">WEB-INF/jboss-scanning.xml</code> with the following content:</p>
<pre class="programlisting"><span class="hl-tag">&lt;scanning</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"urn:jboss:scanning:1.0"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-generic" href="#aop-aj-ltw-environment-generic"></a>Generic Java applications</h5></div></div></div>
<p>When class instrumentation is required in environments that do not support or are not
supported by the existing <code class="literal">LoadTimeWeaver</code> implementations, a JDK agent can be the only
solution. For such cases, Spring provides <code class="literal">InstrumentationLoadTimeWeaver</code>, which
requires a Spring-specific (but very general) VM agent,
<code class="literal">org.springframework.instrument-{version}.jar</code> (previously named <code class="literal">spring-agent.jar</code>).</p>
<p>To use it, you must start the virtual machine with the Spring agent, by supplying the
following JVM options:</p>
<pre class="literallayout">-javaagent:/path/to/org.springframework.instrument-{version}.jar</pre>
<p>Note that this requires modification of the VM launch script which may prevent you from
using this in application server environments (depending on your operation policies).
Additionally, the JDK agent will instrument the <span class="emphasis"><em>entire</em></span> VM which can prove expensive.</p>
<p>For performance reasons, it is recommended to use this configuration only if your target
environment (such as <a class="ulink" href="https://www.eclipse.org/jetty/" target="_top">Jetty</a>) does not have (or does not
support) a dedicated LTW.</p>
</div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-resources" href="#aop-resources"></a>11.9 Further Resources</h2></div></div></div>
<p>More information on AspectJ can be found on the <a class="ulink" href="https://www.eclipse.org/aspectj" target="_top">AspectJ
website</a>.</p>
<p>The book <span class="emphasis"><em>Eclipse AspectJ</em></span> by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a
comprehensive introduction and reference for the AspectJ language.</p>
<p>The book <span class="emphasis"><em>AspectJ in Action, Second Edition</em></span> by Ramnivas Laddad (Manning, 2009) comes highly
recommended; the focus of the book is on AspectJ, but a lot of general AOP themes are
explored (in some depth).</p>
</div>
</div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tbody><tr><td width="40%" align="left"><a accesskey="p" href="expressions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="spring-core.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="aop-api.html">Next</a></td></tr><tr><td width="40%" valign="top" align="left">10. Spring Expression Language (SpEL) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" valign="top" align="right"> 12. Spring AOP APIs</td></tr></tbody></table></div><script async="" data-savepage-src="//www.google-analytics.com/analytics.js" src=""></script><script></script></body><script data-savepage-src="moz-extension://ff0bdfff-cb7a-4f39-a197-a4622934b2d2/js/inject.js" src=""></script></html>